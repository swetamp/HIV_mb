---
title: "HIV Microbiome Analyses - Patel et al"
author: "Sweta Patel"
date: "5/15/2023"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


**General order of steps**
1. Basic demographics
2. Alpha diversity analyses
3. Transform data (CLR) and do Beta-diversity analyses (PCoA plots, PERMANOVA)
  #UPDATE 5/5: the order covariables are listed in PERMANOVA affects the results
4. Generate relative abundance plots using NON-transformed data
5. UPDATE 5/21: Filter on mean relative abundance of 50 and remove NOS species
6. Differential abundance analyses using Maaslin and FILTERED data
    #set Q value to 0.1-0.2
7. Logistic regression analyses (Aim 2)

*Note: these analyses utilize a pruned and decontaminated phyloseq object containing a cleaned taxtable and new variables created from the original variables recorded in REDCap. All coding can be found in the "Fog KAIJU 10-6-23" file.*

```{r include=FALSE}
#Loading packages 
library(plyr)
library(dplyr)
library(ggplot2)
library(phyloseq)
library(tidyr)
library(vegan)
library(metagenomeSeq)
library(httr)
library(gridExtra)
library(data.table)
library(RColorBrewer)
library(scales)
library(gsubfn)
library(readxl)
library(microbiome)
library(MASS)
library(Maaslin2)
library(cowplot)
library(cluster)
library(devtools)
library(SpiecEasi)
```

```{r include=FALSE}
set.seed(1234)
#can't set wd in RMD file; entered below code into console directly
# setwd("OneDrive - Duke University/Fogarty coding/Sequencing/")
```

### Importing and cleaning data

```{r, results = FALSE}
pruned <- readRDS("/Users/swetapatel/OneDrive - Duke University/Fogarty coding/Sequencing/phy.pruned05092022.rds")
#confirm the taxtable, etc looks good:
test <- as.data.frame(as(tax_table(pruned),"matrix"),stringsAsFactors=FALSE)  #success!
meta_prune <- data.frame(sample_data(pruned))
meta_prune <- within(meta_prune, rm(sib_weight, sib_sex, sib_height, sib_muac, sib_race, sib_bfeed_1,
                                  sib_bfeed_2, sib_uri_recent, sib_uri_current, sib_pcr_1, sib_pcr_2,
                                  sib_bcg, sib_hepb, sib_clinic, sib_clinic_dx___5, sib_clinic_dx_oth,
                                  sib_hosp, sib_meds, sib_meds_name, sibmo, sibyr, sib_vl1_weeks, sib_vl_weeks2,
                                  sib_med_days, sib_dpt, sib_pcv, sib_rota, sib_polio, sib_measles, sib_age, samp_storage,
                                  enr_clinic, enr_clinic_other, mat_np))
remove(test)
```

### Demographics of participants with sequencing results

N= 272 participants with sequencing results (of 309 enrolled participants)

```{r}
child <- subset(meta_prune, subject == "child") #n=143
table(child$hiv)  #50 HUU kids, 49 HEU kids, 44 HIV+ kids

#Age
hist(child$age)
summary(child$age)
tapply(child$age, child$hiv, summary)
kruskal.test(child$age, child$hiv)

#Sex
table(child$sex)  #74 girls
table(child$sex, child$hiv)
prop.table(table(child$sex, child$hiv), 2)
summary(table(child$sex, child$hiv))

#Maternal age
hist(child$mat_age2)  #looks quite normal, but will still present median and IQR for consistency
summary(child$mat_age2)
tapply(child$mat_age2, child$hiv, summary)
kruskal.test(child$mat_age2, child$hiv)

#Season
table(child$season) 
table(child$season, child$hiv)
prop.table(table(child$season, child$hiv), 2)
summary(table(child$season, child$hiv))

#Maternal education
table(child$mat_educ)
table(child$mat_educ2)
table(child$mat_educ2, child$hiv)
prop.table(table(child$mat_educ2, child$hiv), 2)
summary(table(child$mat_educ2, child$hiv))
fisher.test(child$mat_educ2, child$hiv)

#Electricity
table(child$elec) #106 children have electricity
table(child$elec, child$hiv)
prop.table(table(child$elec, child$hiv), 2)
summary(table(child$elec, child$hiv))

#Wood
table(child$wood) #90 children in households using wood
table(child$wood, child$hiv)
prop.table(table(child$wood, child$hiv), 2)
summary(table(child$wood, child$hiv))

#Num household members
hist(child$hhsize)
summary(child$hhsize)
tapply(child$hhsize, child$hiv, summary)
kruskal.test(child$hhsize, child$hiv)

#Num children <5
hist(child$num_child)
summary(child$num_child)
tapply(child$num_child, child$hiv, summary)
kruskal.test(child$num_child, child$hiv)

#antibiotics
table(child$abx) #24 children received abx
table(child$abx, child$hiv)
prop.table(table(child$abx, child$hiv), 2)
summary(table(child$abx, child$hiv))

#Clinic in past 3 months
table(child$clinic)
table(child$clinic, child$hiv)
prop.table(table(child$clinic, child$hiv), 2)
summary(table(child$clinic, child$hiv))

#URI in past 1 month
table(child$uri_recent)
table(child$uri_recent, child$hiv)
prop.table(table(child$uri_recent, child$hiv), 2)
summary(table(child$uri_recent, child$hiv))

#URI currently (don't need both this and uri recent in table 1; need to choose)
table(child$uri_current)
table(child$uri_current, child$hiv)
prop.table(table(child$uri_current, child$hiv), 2)
summary(table(child$uri_current, child$hiv))

#Hospital in past 3 months -->> 4 children hospitalized, all 4 HIV+
  #*MENTION IN MANUSCRIPT
table(child$hosp)
table(child$hosp, child$hiv)
table(child$hosp_dx)  #1 with lower respiratory infx, 1 with gastroenteritis, 2 with other
table(child$hosp_dx_oth)  #malnutrition, sepsis + chronic suppurative OM

#PCV doses
table(child$pcv)
table(child$pcv, child$hiv)
prop.table(table(child$pcv, child$hiv), 2)
summary(table(child$pcv, child$hiv))
fisher.test(child$pcv, child$hiv)

#HiB
table(child$dpt)
table(child$dpt, child$hiv)
prop.table(table(child$dpt, child$hiv), 2)
summary(table(child$dpt, child$hiv))
fisher.test(child$dpt, child$hiv)

#breakdown of subjects (not for table 1, but for sequencing figure)
table(meta_prune$subject)
```

### HIV-specific variables
```{r}
chi_hiv <- subset(child, hiv == "Infected")
#restrict to just HIV variables for easier cleaning and analysis
chi_hiv <- chi_hiv[c("child_pcr_1", "child_vl_1", "child_pcr_2", "child_vl_2", "chi_cd4_num_1", 
                     "chi_cd4_perc_1", "chi_cd4_num_2", "chi_cd4_perc_2", "chi_cd4_weeks1", 
                     "chi_cd4_weeks2", "child_vl1_weeks", "child_vl2_weeks",
                     "child_arv", "child_arv_meds", "child_tmpsmx", "abx")]

#How many kids receiving TMP-SMX? NOTE: we did not include these kids in the abx category. Need to re-do analyses with this included?
table(chi_hiv$child_tmpsmx) #15 kids on TMP-SMX
#manual inspection: 10 kids on TMP-SMX without other abx exposure

#I want the most recent viral load values for my analysis. Will try creating a new variable to ID which value is more recent first:
#missing 3 vl1 and 14vl2's
chi_hiv$newest_vL <- NA
chi_hiv$newest_vL [chi_hiv$child_vl1_weeks < chi_hiv$child_vl2_weeks] <- 1
chi_hiv$newest_vL [chi_hiv$child_vl2_weeks < chi_hiv$child_vl1_weeks] <- 2
chi_hiv$newest_vL [chi_hiv$child_vl2_weeks < 0] <- 1  #we want to include the viral loads collected BEFORE enrollment where possible
chi_hiv$newest_vL [is.na(chi_hiv$child_vl_2)] <- 1    #if we are missing vl_2, we will use vl_1
chi_hiv$newest_vL [is.na(chi_hiv$child_vl_1) & is.na(chi_hiv$child_vl_2)] <- NA
table(chi_hiv$newest_vL)

#Next, can we pull the viral load that was most recent using our newest_vL variable?
  #source: https://stackoverflow.com/questions/67944727/creating-new-variable-by-selecting-column-based-on-value-of-another-column
  #Need to do this with rows that have values (aka need to exclude the NA viral load children for this to work)
#For future phyloseq analyses: will need to remove B-04, B-07, B-52
chi_viral <- subset(chi_hiv, !is.na(newest_vL))
chi_viral$Var1 <- chi_viral$child_vl_1
chi_viral$Var2 <- chi_viral$child_vl_2

chi_viral <- chi_viral %>% rowwise() %>%
  mutate(newest_vlnum = get(paste0('Var', newest_vL)))
#now we have a dataframe of the 41 children with viral load measurements and 1 column containing the most recent viral loads for each
summary(chi_viral$newest_vlnum)
table(chi_viral$newest_vlnum) #27 with viral suppression, 14 without viral suppression

#make new variable for viral suppression or not, with vL < 400 = suppressed
chi_viral$vl_suppr <- NA
chi_viral$vl_suppr [chi_viral$newest_vlnum < 400] <- "1"
chi_viral$vl_suppr [chi_viral$newest_vlnum >= 400] <- "0"
table(chi_viral$vl_suppr)

#REPEAT the above steps to get date associated with most recent viral load, most recent CD4, and date a/w most recent CD4
#Viral load collection date
chi_viral$Var1 <- chi_viral$child_vl1_weeks
chi_viral$Var2 <- chi_viral$child_vl2_weeks

chi_viral <- chi_viral %>% rowwise() %>%
  mutate(newest_vldate = get(paste0('Var', newest_vL)))   #now have info for when vL were checked in relation to enrollment

summary(chi_viral$newest_vldate)

chi_viral <- within(chi_viral, rm(Var1, Var2))

#CD4
  #missing CD4 data for B-45 and B-52
  #will focus on percentages since this is what is presented for kids
chi_hiv$newest_cd4 <- NA
chi_hiv$newest_cd4 [chi_hiv$chi_cd4_weeks1 < chi_hiv$chi_cd4_weeks2] <- 1
chi_hiv$newest_cd4 [chi_hiv$chi_cd4_weeks2 < chi_hiv$chi_cd4_weeks1] <- 2
chi_hiv$newest_cd4 [chi_hiv$chi_cd4_weeks2 < 0] <- 1  #we want to include the viral loads collected BEFORE enrollment where possible
chi_hiv$newest_cd4 [is.na(chi_hiv$chi_cd4_perc_2)] <- 1    #if we are missing cd4_2, we will use cd4_1
chi_hiv$newest_cd4 [is.na(chi_hiv$chi_cd4_perc_1)] <- 2    #one child is missing cd4_1 but has cd4_2
chi_hiv$newest_cd4 [is.na(chi_hiv$chi_cd4_perc_1) & is.na(chi_hiv$chi_cd4_perc_2)] <- NA
table(chi_hiv$newest_cd4)

#create new dataframe without B-45 and B-52 (aka new df with children missing CD4 data removed)
chi_cd4 <- subset(chi_hiv, !is.na(newest_cd4))
chi_cd4$Var1 <- chi_cd4$chi_cd4_perc_1
chi_cd4$Var2 <- chi_cd4$chi_cd4_perc_2

chi_cd4 <- chi_cd4 %>% rowwise() %>%
  mutate(newest_cd4perc = get(paste0('Var', newest_cd4)))

summary(chi_cd4$newest_cd4perc)
table(chi_cd4$newest_cd4perc)

#make new variable for immune competent CD4 or not, with CD4 percentage *** = immune competent
  #See sub-analyses file for code

#arvs
table(chi_hiv$child_arv)
table(chi_hiv$child_arv_meds)
```

### Number of reads by subject class and HIV status

*using pruned and agglomerated reads*

```{r}
summary(meta_prune$paired.reads)   #Median (IQR) of 73,166 (29,605; 217,115) reads per sample
#mean 183,726 reads per sample
hist(meta_prune$paired.reads)

#Did maternal samples contain more reads than child or sib reads? --> the opposite! Why?
#children = petri dishes
tapply(meta_prune$paired.reads, meta_prune$subject, summary)
kruskal.test(meta_prune$paired.reads, meta_prune$subject)

#number of reads
hist(child$paired.reads)
summary(child$paired.reads)
tapply(child$paired.reads, child$hiv, summary)
kruskal.test(paired.reads ~ hiv, data = child) 

#Sum of sequences
sum(sample_sums(pruned))     #35,101,748 sequences obtained 
mean(sample_sums(pruned))    #Mean of 129,050.5 sequences per sample
median(sample_sums(pruned))  #Median of 45,235 sequences per sample
summary(sample_sums(pruned)) #IQR of sequencing reads per sample: 15730, 146428
nsamples(pruned)        #272 NP samples 
ntaxa(pruned) #6709 taxa
```

### Alpha diversity measures

*Create dataframe*

```{r}
#Create dataframe with diversity indices for each specimen using PRUNED pseq object
diversity <- estimate_richness(pruned, measures = c("Shannon", "Simpson", "Chao1", "Observed"))

setDT(diversity, keep.rownames = TRUE)[]
colnames(diversity) <- c("sample_id", "Observed", "Chao1", "se.chao1", "Shannon", "Simpson")
rownames(diversity) <- diversity$sample_id
diversity <- merge(diversity, meta_prune, by="sample_id")
```

#### Observed species

```{r}
#How many species on average per sample? Did that differ by subject or by HIV status (among children only)?
hist(diversity$Observed)
summary(diversity$Observed) 
sd(diversity$Observed)
#Median (IQR) # spec: 106 (53, 260)
#Mean (SD): 216 (300)

#what does it look like by subject? Moms have significantly fewer species per sample
tapply(diversity$Observed, diversity$subject, summary)   
kruskal.test(Observed ~ subject, data = diversity)

#what about by HIV status of the child? No signif diff
div_child <- subset(diversity, subject == "child")
tapply(div_child$Observed, div_child$hiv, summary)
kruskal.test(Observed ~ hiv, data = div_child) 
```

#### Shannon

```{r}
#Is our SDI data normally distributed? 
shapiro.test(diversity$Shannon)  #technically no, because p<0.05; looks pretty good on histogram but QQ is wonky
histogram(diversity$Shannon)
qqnorm(diversity$Shannon, pch = 1, frame = FALSE)
qqline(diversity$Shannon, col = "steelblue", lwd = 2)

#Shannon diversity median and IQR for all samples
summary(diversity$Shannon)
sd(diversity$Shannon)
#Median (IQR) SDI: 1.85 (1.51, 2.26)
#Mean (SD) 1.93 (0.66)  

#what does it look like by subject? 
tapply(diversity$Shannon, diversity$subject, summary)
kruskal.test(Shannon ~ subject, data = diversity) #child signif lower (p=0.01)
#Since our data is normal-ish in distribution, what does the ANOVA look like?
subj.aov <- aov(Shannon ~ subject, data = diversity)
summary(subj.aov)   #P value 0.007; SIGNIFICANT
table(diversity$subject)

#what about by HIV status of the child?
tapply(div_child$Shannon, div_child$hiv, summary)
kruskal.test(Shannon ~ hiv, data = div_child)   #no significant difference by HIV status using KW test (P=0.71)
  #ANOVA
hiv.aov <- aov(Shannon ~ hiv, data = div_child)
summary(hiv.aov)  #P=0.37, not significant

#Age of the child
div_age <- lm(Shannon ~ age, data = div_child)
summary(div_age)  #p=0.98

#Wood smoke exposure
tapply(div_child$Shannon, div_child$wood, summary)
wilcox.test(Shannon ~ wood, data = div_child)   #p=0.30
t.test(Shannon ~ wood, data = div_child)        #P=0.73

#Season
tapply(div_child$Shannon, div_child$season, summary)
wilcox.test(Shannon ~ season, data = div_child)   #p=0.69
t.test(Shannon ~ season, data = div_child)  #P=0.70

#Receipt of abx in prior 3 months 
tapply(div_child$Shannon, div_child$abx, summary)
wilcox.test(Shannon ~ abx, data = div_child)   #p=0.86
t.test(Shannon ~ abx, data = div_child)   #P=0.71

#Current URI
tapply(div_child$Shannon, div_child$uri_cur2, summary)
wilcox.test(Shannon ~ uri_cur2, data = div_child) #p=0.65
t.test(Shannon ~ uri_cur2, data = div_child) #p=0.37

#Recent URI
tapply(div_child$Shannon, div_child$uri_rec2, summary)
wilcox.test(Shannon ~ uri_rec2, data = div_child) #p=0.30
t.test(Shannon ~ uri_rec2, data = div_child) #p=0.31

#Household members
summary(div_hh <- lm(Shannon ~ hhsize, data = div_child)) #p=0.47

#MULTIVARIABLE MODEL
#Need to set reference for HIV variable
class(div_child$hiv) #character; need to make factor to relevel
div_child$hiv <- as.factor(div_child$hiv)
div_child$hiv <- relevel(div_child$hiv, ref = "Unexposed")
summary(div_mv <- lm(Shannon ~ age + hiv + wood + season + abx + uri_rec2, data = div_child))
summary(div_mv <- lm(Shannon ~ age + hiv + wood + season + abx + uri_rec2 + hhsize, data = div_child))
```

#### Chao1

```{r}
#Is our Chao1 data normally distributed? 
shapiro.test(diversity$Chao1)  #no, because p<0.05; also looks skewed on histogram and QQ is wonky
histogram(diversity$Chao1)
qqnorm(diversity$Chao1, pch = 1, frame = FALSE)
qqline(diversity$Chao1, col = "steelblue", lwd = 2)

#What does it look like if we log transform it? Will this allow for parametric testing?
diversity$Chao1_log <- log(diversity$Chao1)
shapiro.test(diversity$Chao1_log) 
histogram(diversity$Chao1_log)
qqnorm(diversity$Chao1_log, pch = 1, frame = FALSE)
qqline(diversity$Chao1_log, col = "steelblue", lwd = 2)
  #Looks very normal! Can use t.test and linear regression on transformed data
div_child <- subset(diversity, subject == "child")

#Chao1 median and IQR for all samples
summary(diversity$Chao1)
sd(diversity$Chao1)
#Median (IQR) Chao1: 106 (53, 260)
#Mean (SD) 216 (300.4)

#what does it look like by subject? 
tapply(diversity$Chao1, diversity$subject, summary)
tapply(diversity$Chao1_log, diversity$subject, summary) #log mean of moms is lower
summary(aov(Chao1_log ~ subject, data = diversity)) #significant difference (p=0.03)

#what about by HIV status of the child?
tapply(div_child$Chao1, div_child$hiv, summary)
tapply(div_child$Chao1_log, div_child$hiv, summary)
summary(aov(Chao1_log ~ hiv, data = div_child)) #no significant difference by HIV status using log values and ANOVA (p=0.2)

#Age of the child
summary(div_age <- lm(Chao1_log ~ age, data = div_child)) #p=0.38

#Wood smoke exposure
tapply(div_child$Chao1, div_child$wood, summary)
t.test(Chao1_log ~ wood, data = div_child)    #p=0.93

#Season
tapply(div_child$Chao1, div_child$season, summary)
t.test(Chao1_log ~ season, data = div_child)    #p=0.43

#Receipt of abx in prior 3 months 
tapply(div_child$Chao1, div_child$abx, summary)
t.test(Chao1_log ~ abx, data = div_child)    #p=0.92

#Current URI  #p=0.06
tapply(div_child$Chao1_log, div_child$uri_cur2, summary)
t.test(Chao1_log ~ uri_cur2, data = div_child)

#Recent URI 
tapply(div_child$Chao1_log, div_child$uri_rec2, summary)
t.test(Chao1_log ~ uri_rec2, data = div_child)  #p=0.69

#Household members
summary(div_hh <- lm(Chao1_log ~ hhsize, data = div_child)) #p=0.42

#MULTIVARIABLE MODEL
#log with HUU as reference value
class(div_child$hiv) #character; need to make factor to relevel
div_child$hiv <- as.factor(div_child$hiv)
div_child$hiv <- relevel(div_child$hiv, ref = "Unexposed")
summary(div_mv <- lm(Chao1_log ~ age + hiv + wood + season + abx + uri_rec2, data = div_child))
summary(div_mv <- lm(Chao1_log ~ age + hiv + wood + season + abx + uri_cur2, data = div_child))
summary(div_mv <- lm(Chao1_log ~ age + hiv + wood + season + abx + uri_rec2 + hhsize, data = div_child))
```

#### Alpha diversity boxplots

- Helpful resource for boxplots: http://www.sthda.com/english/wiki/ggplot2-box-plot-quick-start-guide-r-software-and-data-visualization

```{r}
#make new variable with HIV status abbreviated
div_child$hiv2 <- NA
div_child$hiv2 [div_child$hiv == "Infected"] <- "CLWH"
div_child$hiv2 [div_child$hiv == "Exposed Uninfected"] <- "HEU children"
div_child$hiv2 [div_child$hiv == "Unexposed"] <- "HUU children"
table(div_child$hiv2)
#matches up with table(relative_df$hiv)
div_child$hiv2 <- as.factor(div_child$hiv2)
div_child$hiv2 <- reorder(div_child$hiv2, new.order=c("CLWH", "HEU children", "HUU children"))

#Shannon boxplot 
s1a2 <- ggplot(div_child, aes(x=hiv2, y=Shannon, fill=hiv2)) + 
  geom_boxplot() + labs(x="HIV status", y = "Shannon index")+
  scale_fill_manual(values=c('#800000FF','#155F83FF', '#FFA319FF')) +
  theme_classic() +
  theme(
    legend.text = element_text(size = 10),
    legend.position = "none",
    legend.title = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.y = element_text(size = 12),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank())

#Chao1 by HIV (to create legend we will use for our combined figure)
s1b <- ggplot(div_child, aes(x=hiv2, y=Chao1, fill=hiv2)) + 
  geom_boxplot() + labs(x="HIV status", y = "Chao1 richness")+
  scale_fill_manual(values=c('#800000FF','#155F83FF', '#FFA319FF')) +
  theme_classic() +
  theme(
    legend.text = element_text(size = 10),
    legend.position = "right",
    legend.title = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.y = element_text(size = 12),
    axis.title.x = element_blank(),
    axis.text.x = element_text(size=10, angle = 45, vjust = 1, hjust = 1, colour = "black"))

#Chao1 boxplot with no legend
s1b2 <- ggplot(div_child, aes(x=hiv2, y=Chao1, fill=hiv2)) + 
  geom_boxplot() + labs(x="HIV status", y = "Chao1 richness")+
  scale_fill_manual(values=c('#800000FF','#155F83FF', '#FFA319FF')) +
  theme_classic() +
  theme(
    legend.text = element_text(size = 10),
    legend.position = "none",
    legend.title = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.y = element_text(size = 12),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.x = element_blank())

#Get legend only to make it easier to size all parts of the figure
legend <- get_legend(s1b)

#combine the versions using cowplot to create supplemental Figure S1
prow2 <- plot_grid(s1a2, s1b2, labels = "AUTO", nrow = 1, ncol = 2, align = "h", axis = "b", rel_widths = c(1,1.1))
FigS1_v2 <- plot_grid(prow2, legend, rel_widths = c(2, 0.5))

png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/FigS1_v2.png",
    width = 7, height = 3.5, units = 'in', res = 600)
FigS1_v2
dev.off()

#save as .eps file to comply with Lancet Microbe requirements
ggsave(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/FigS1_v2.eps", width = 7, height = 3.5, units = "in")
FigS1_v2
dev.off()

#clean up environment
remove(div_age, div_mv, hiv.aov, m1, subj.aov)
```
- source for saving as .eps: https://stackoverflow.com/questions/5142842/export-a-graph-to-eps-file-with-r

### Beta diversity measures

*In order to compare overall composition by HIV status, we will first CLR transform our data and use euclidean distances for comparison*

- Sources: https://rdrr.io/github/microbiome/microbiome/man/transform.html
  https://microbiome.github.io/tutorials/Preprocessing.html

```{r}
pruned_clr <- microbiome::transform(pruned, "clr")
chi_clr = subset_samples(pruned_clr, subject == "child")
```

#### Beta diversity plots

- will save in .eps format for consistency with Lancet Microbe requirements

```{r}
#First: create new HIV variable as factor, then relevel
table(child$hiv)
child$hiv2 <- NA
child$hiv2 [child$hiv == "Infected"] <- "CLWH"
child$hiv2 [child$hiv == "Exposed Uninfected"] <- "HEU children"
child$hiv2 [child$hiv == "Unexposed"] <- "HUU children"
table(child$hiv2)
class(child$hiv2)
child$hiv2 <- as.factor(child$hiv2)
child$hiv2 <- reorder(child$hiv2, new.order=c("CLWH", "HEU children", "HUU children"))

#Import back into pseq (source: https://jacobrprice.github.io/2017/08/26/phyloseq-to-vegan-and-back.html)
sample_data(chi_clr) <- as.data.frame(child)
#now see if it worked:
bloop <- data.frame(sample_data(chi_clr))
table(bloop$hiv2)
#success!
remove(bloop)

#Now ordinate and create PCOA plot
clr_pcoa <- ordinate(chi_clr, method = "PCoA", distance = "euclidean")
p1 <- plot_ordination(chi_clr, clr_pcoa, color = "hiv2") +
  geom_point(size = 0.005) + theme_classic() + theme(
    plot.title = element_text(size = 14, hjust = 0.5),
    legend.title = element_blank(),
    legend.text = element_text(size = 10),
    legend.position = "right",
    legend.background = element_blank(),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)) +
  scale_color_manual(values=c('#800000FF','#155F83FF', '#FFA319FF'))+
  stat_ellipse(aes(linetype=hiv2), geom="polygon", alpha=0, type="t", level=0.8, size=0.5) +
  xlab("PC1 (14.4%)") + ylab("PC2 (8.9%)") +
  scale_linetype_manual(values= c("dashed", "dashed", "dashed"))
```

#### Permanova

- NOTE: since initial analysis, adonis has been depreciated so all analyses here updated with adonis2

```{r}
#Create OTU table
otu <- as.data.frame(otu_table(chi_clr, taxa_are_rows=TRUE))

#Need species in columns and observations in rows: transpose using t() function and save as a dataframe
  #Source: https://github.com/edamame-course/2015-tutorials/blob/master/final/Ashley_Intro_to_R.md
otu_trans <- data.frame(t(otu))
child <- data.frame(sample_data(chi_clr))

#Calculate distance and save as a matrix
BC.dist=vegdist(otu_trans, method="euclidean")

#HIV
# adonis(BC.dist ~ hiv, data = child, permutations = 1000)
  #Significant difference by HIV status among children (P = 0.043, R^2 = 0.019)
adonis2(BC.dist ~ hiv, data = child, permutations = 1000)
  #Significant difference by HIV status remains: R2 = 0.019, P = 0.039

#HIV + age (per 6/9/23 MK discussion to account for age in all PERMANOVAs)
#NOTE re: adonis2 'by' function: "by = "terms" will assess significance for each term (sequentially from first to last), setting by = "margin" will assess the marginal effects of the terms (each marginal term analysed in a model with all other variables)"
#Source: https://search.r-project.org/CRAN/refmans/vegan/html/adonis.html
#Previously, we used the by = "terms" function and ordered terms in multivariable models based on the R2 from each univariable model. However, it is worth exploring the by = "margin" so we can look at the marginal effects of all variables together.
# adonis(BC.dist ~ hiv + age, data = child, permutations = 1000)
  #Significant difference by HIV status among children (P = 0.042, R^2 = 0.019)
    #Significant difference by age as well (P = 0.03, R^2 = 0.012)

#NEW adonis2 code with by = "terms" and by = "margins"
adonis2(BC.dist ~ hiv + age, data = child, permutations = 1000, by = "terms")
  #Significant difference by HIV status among children (P = 0.036, R2 = 0.019) and by age (P = 0.023, R2 = 0.012
adonis2(BC.dist ~ hiv + age, data = child, permutations = 1000, by = "margin")
  #results are pretty consistent: HIV: p = 0.043, R2 = 0.019; age: p = 0.02, R2 = 0.12

#Age
adonis2(BC.dist ~ age, data = child, permutations = 1000)
  #Significant difference in overall composition by age (P = 0.03, R2 = 0.012)

#Season
  #Significant difference in overall composition by season (P < 0.001, R2 = 0.016)
adonis2(BC.dist ~ season, data = child, permutations = 1000)
  #Season + age (per 6/9 MK discussion to account for age in all PERMANOVAs)
adonis2(BC.dist ~ season + age, data = child, permutations = 1000, by = "terms")
adonis2(BC.dist ~ season + age, data = child, permutations = 1000, by = "margin")
#Significant difference by season (P = 0.002, R^2 = 0.016) and age (P = 0.03, R2 = 0.011) by "terms"
#Consistent by "margin": season (P = 0.004, R^2 = 0.016) and age (P = 0.03, R2 = 0.011)

#Wood
adonis2(BC.dist ~ wood, data = child, permutations = 1000)
  #No significant difference by wood smoke exposure among children (P = 0.12)
#Wood + age (per 6/9 MK discussion to account for age in all PERMANOVAs)
adonis2(BC.dist ~ wood + age, data = child, permutations = 1000, by = "terms")
#No signif difference by wood smoke exposure (P = 0.09) but age remains signif: (P = 0.02, R^2 = 0.012)
adonis2(BC.dist ~ wood + age, data = child, permutations = 1000, by = "margin") #consistent

#Abx
adonis2(BC.dist ~ abx, data = child, permutations = 1000)
  #Trend but no significant difference in overall composition by abx exposure (P = 0.08)
#Abx + age (per 6/9 MK discussion to account for age in all PERMANOVAs)
adonis2(BC.dist ~ abx + age, data = child, permutations = 1000, by = "terms")
#Trend but no significant difference in overall composition by abx exposure (P = 0.06) and age remains significant; same for by = "margin"
adonis2(BC.dist ~ abx + age, data = child, permutations = 1000, by = "margin")

#Recent URI
adonis2(BC.dist ~ uri_rec2, data = child, permutations = 1000)
#Significant difference in composition among children with recent URI (P = 0.008, R2=0.015)
  #Recent URI + age (per 6/9 MK discussion to account for age in all PERMANOVAs)
adonis2(BC.dist ~ uri_rec2 + age, data = child, permutations = 1000, by = "terms")
adonis2(BC.dist ~ uri_rec2 + age, data = child, permutations = 1000, by = "margin")
#Significant difference in composition by recent URI sx status (R2 = 0.015, p=0.004) and age (R2 = 0.11, p = 0.04) using both "terms" and "margin"

#Multivariable
  #NOTE: order of variables affects results when using by = "terms" per link above
#start with model that lists covariables by effect size from univariable analysis (signif variables only)
  #HIV R2 = 0.019, season R2 = 0.016, recent URI R2=0.015, age: R2 = 0.012
adonis2(BC.dist ~ hiv + season + uri_rec2 + age, data = child, permutations = 1000, by = "terms")
pm <- adonis2(BC.dist ~ hiv + season + uri_rec2 + age, data = child, permutations = 1000, by = "margin")
pm
  #In a multivariable model, HIV status (P=0.04, R2=0.019), season (P=0.002, R2=0.016), recent URI (P=0.01, R2=0.013), and age (P=0.04, R2=0.011) were a/w differences in overall microbiome composition using both by = options (above R2 and p values are from by = "margin")
```

Statistical reviewer from Lancet Microbe requested 95% CI for each R2 we presented. From web review appears the most straightforward way to obtain these values is through bootstrapping:
https://stats.stackexchange.com/questions/175026/formula-for-95-confidence-interval-for-r2
https://rstudio-pubs-static.s3.amazonaws.com/288625_b0cf85c5be974eb795cef778535289d8.html

General tutorial on bootstrapping:
https://stats.oarc.ucla.edu/r/faq/how-can-i-generate-bootstrap-statistics-in-r/

```{r}
library(boot)
test <- function(child,i) {
  test2 <- child[i,]
  return(adonis2(BC.dist ~ hiv + season + uri_rec2 + age, data = child, permutations = 1000, by = "margin"))
}

set.seed(1234)
boota <- boot(child, test, R=1000)
boota

#This isn't working; will try to bootstrap with a simpler test to better understand the code first using UCLA tutorial
hsb2 <- read.table("https://stats.idre.ucla.edu/stat/data/hsb2.csv", sep=",", header=T)
fc <- function(d, i){
	d2 <- d[i,]
	return(cor(d2$write, d2$math))
}

# set.seed(626)
bootcorr <- boot(hsb2, fc, R=500)
bootcorr
summary(bootcorr)

```

We also received a reviewer comment requesting unsupervised clustering to clarify if there are some hidden groups among the data, so we will add this analysis. We tried Dirichlet Multinomial Models as suggested by the reviewer, but this was unsuccessful and we ultimately successfully used k-medioid clustering as done by McCumber et al in CID paper, using the code shared on his github: https://github.com/alexmccumber/BRAVE_Kids

#### K-medioid clustering

```{r}
chi_prune = subset_samples(pruned, subject == "child")
phy.otus <- transform_sample_counts(chi_prune, function(Abundance) Abundance/sum(Abundance))
otu_df <- psmelt(phy.otus)
otu_df$OTU <- as.character(otu_df$OTU)
otu_abundances <- aggregate(otu_df$Abundance, by=list(OTU=otu_df$OTU), FUN=sum)
otu_abundances$x <- (otu_abundances$x)/(nsamples(chi_prune))
names(otu_abundances)[names(otu_abundances) == 'x'] <- 'otu_Ab'
sum(otu_abundances$otu_Ab)  #sums to 1
nrow(otu_abundances)        #6709 species
remove(phy.otus, otu_df)

# Agglomerate taxa into species --> already done, so no need to do again
# Transform to relative abundances
chi.rel <- transform_sample_counts(chi_prune, function(Abundance) Abundance/sum(Abundance))
sample_sums(chi.rel)  # This is a sanity check to make sure that relative abundance was calculated for each sample prior to pooling data
#All samples add to 1
melted_df <- psmelt(chi.rel)

#clean up melted_df
melted_df <- within(melted_df, rm(sib_weight, sib_sex, sib_height, sib_muac, sib_race, sib_bfeed_1,
                                    sib_bfeed_2, sib_uri_recent, sib_uri_current, sib_pcr_1, sib_pcr_2,
                                    sib_bcg, sib_hepb, sib_clinic, sib_clinic_dx___5, sib_clinic_dx_oth,
                                    sib_hosp, sib_meds, sib_meds_name, sibmo, sibyr, sib_vl1_weeks, sib_vl_weeks2,
                                    sib_med_days, sib_dpt, sib_pcv, sib_rota, sib_polio, sib_measles, 
                                    sib_age, samp_storage, enr_clinic, enr_clinic_other, mat_np))
```


```{r}
# Function to make matrix usable for vegan from phyloseq object
vegan_otu <- function(physeq) {
    OTU <- otu_table(physeq)
    if (taxa_are_rows(OTU)) {
        OTU <- t(OTU)
    }
    return(as(OTU, "matrix"))
}

#Aggregate at species level and drop NA reads for the distance and clustering
test <- as.data.frame(as(tax_table(chi.rel),"matrix"),stringsAsFactors=FALSE)

chi.spec = tax_glom(chi.rel, taxrank = "Species") 

DistType = t(as.data.frame(vegan_otu(chi.spec)))

data.dist = vegdist(vegan_otu(chi.spec), method = "bray")

pam.clustering=function(x,k) { # x is a distance matrix and k the number of clusters
                         require(cluster)
                         cluster = as.vector(pam(as.dist(x), k, diss=TRUE)$clustering)
                         return(cluster)
                        }

#See how many clusters is ideal (range from 1 to 20)

nclusters=NULL
library(clusterSim)
for (k in 1:20) { 
		if (k==1) {
			nclusters[k]=NA 
		} else {
			data.cluster_temp=pam.clustering(data.dist, k)
			nclusters[k]=index.G1(t(DistType), data.cluster_temp,  d = data.dist,
			centrotypes = "medoids")
		}
	}
```

**Stop after this plot and see how many clusters you have**
```{r}
plot(nclusters, type="h", xlab="k clusters", ylab="CH index")
```

- it looks like 5 clusters is the "best" number (source: https://stats.stackexchange.com/questions/52838/what-is-an-acceptable-value-of-the-calinski-harabasz-ch-criterion)

```{r}
#Set new number of clusters = to k based on above plot
data.cluster=pam.clustering(data.dist, k=5)

nclusters = index.G1(t(DistType), data.cluster, d = data.dist, centrotypes = "medoids")

#look at number to see if it is highest average (or could change mean to median) <- note from Alex; not sure how to interpret
obs.silhouette=mean(silhouette(data.cluster, data.dist)[,3])  #where does the 3 come from?
obs.silhouette=median(silhouette(data.cluster, data.dist)[,3])
  #tutorial on silhouette: https://stat.ethz.ch/R-manual/R-devel/library/cluster/html/silhouette.html
test <- silhouette(data.cluster, data.dist)
summary(test)

library(ade4)
obs.pcoa=dudi.pco(data.dist, scannf=F, nf=3)
  #Get warning for non euclidean distance; we intentionally used non-transformed data and bray-curtis (not euclidean) measures, so not unexpected

#reading about dudi.pco: scannf = TRUE should give you a bar plot of eigenvalues; if FALSE, then nf = number of axes to be kept
  #how do we know that 3 axes is the right number? 
# obs.pcoa=dudi.pco(data.dist, scannf=T) #if using scannf=T, you have to specify the number of axes no matter what
#https://pbil.univ-lyon1.fr/R/pdf/course2.pdf --> tutorial on picking the number of axes using our obs.pcoa
  #also walks you through eigenvalues
obs.pcoa$eig
sum(obs.pcoa$eig) #0.33
barplot(obs.pcoa$eig)
(kip <- 100 * obs.pcoa$eig/sum(obs.pcoa$eig))
cumsum(kip) #viewing the data in a 3d space extracts only 44.5% of the info; we'd have to view in 40 axes to see 99% of the contained information. On the other hand, Alex's PC% were relatively small and the whole point of these plots is dimension reduction. Can d/w MK; do we need to re-do with a higher number of axes?

s.class(obs.pcoa$li, fac=as.factor(data.cluster), grid=T,  col = c(1:5))
  #gives you a cool figure!

p = cbind(obs.pcoa$li,data.cluster)

p$data.cluster = as.factor(p$data.cluster)

library(RColorBrewer)
library(scales)
chisp2 <- c("#293352", "#800000FF", "#767676FF", "#FFA319FF", "#8A9045FF", "#155F83FF", "#C16622FF", "#4D004B", "#8F3931FF", "#58593FFF", "#350E20FF")
show_col(chisp2)
chisp3 <- c("#293352", "#800000FF","#8A9045FF", "#FFA319FF", "#4D004B")
show_col(chisp3) #bit dark, let's make a lighter set of 5 for the cluster boxplots
chisp4 <- c("#155F83FF", "#8F3931FF", "#FFA319FF", "#8A9045FF", "#C16622FF")
show_col(chisp4)

library(ggpubr)
clust <- ggplot(data = p, aes(x = A1, y = A2)) +
  geom_point(data = p, aes(color = data.cluster), alpha=1, size=1.0) + 
  scale_color_manual(values = chisp3) +
  theme_classic() +
    theme(
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12))+
  stat_ellipse(aes(color = data.cluster)) +
  stat_stars(aes(color = data.cluster), show.legend = T) +
  xlab("PC1 (22.6%)") +
  ylab("PC2 (17.3%)") +
  labs(color = "Microbiome Profile")+ 
  scale_y_continuous(labels = scales::number_format(accuracy = 0.1))

clust
#Question: how to tell PC %? Standard axes are A1 and A2 instead of PC% and PC% --> created a pcoa plot by cluster below and used those PC%; make sure this is ok

#save for ease of review; once you figure out how to update the axes accurately and finalize the figure, will need to save as an eps file (sample code below)
png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/clust_v2.png",
    width = 12, height = 9, units = 'in', res = 600)
clust
dev.off()

# #save as .eps file to comply with Lancet Microbe requirements
# ggsave(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/clust.eps", width = 7, height = 3.5, units = "in")
# clust
# dev.off()
```

- Now that we have generated our clusters, we need to add this data to our metadata and see if any of our variables of interest are associated with these clusters

```{r}
sample_data(chi.spec)$cluster = as.factor(data.cluster)

sampleDF = sample_data(chi.spec) %>%
  data.frame(.)

#save sampleDF as a csv file in case we need to return to it
write.csv(sampleDF, '/Users/swetapatel/OneDrive - Duke University/Fogarty coding/metadata_clust.csv')

#To get PC% for axes for above figure:
#Create new PCoA with clusters as variable, using euclidean distances generated from CLR transforming chi.spec
chi.spec_clr <- microbiome::transform(chi.spec, "clr")
clr_pcoa <- ordinate(chi.spec_clr, method = "PCoA", distance = "euclidean")
p1 <- plot_ordination(chi.spec_clr, clr_pcoa, color = "cluster") +
  geom_point(size = 0.005) + theme_classic() + theme(
    plot.title = element_text(size = 14, hjust = 0.5),
    legend.title = element_blank(),
    legend.text = element_text(size = 10),
    legend.position = "right",
    legend.background = element_blank(),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)) +
  scale_color_manual(values = chisp4)+
  stat_ellipse(aes(color = cluster)) +
  stat_stars(aes(color = cluster), show.legend = T) +
  xlab("PC1 (14.3%)") +
  ylab("PC2 (8.9%)") +
  labs(color = "Microbiome Profile")
#gives us axes of 8.9% (y) and 14.3% (x); we will input these back into our figure above and make sure this is appropriate with MK. Weird though because 2 different distances used (euclidean here, bray above) and the clusters look different; what does our pcoa look like if we use bray here too?
clr_pcoa2 <- ordinate(chi.spec, method = "PCoA", distance = "bray")
p1 <- plot_ordination(chi.spec, clr_pcoa2, color = "cluster") +
  geom_point(size = 0.005) + theme_classic() + theme(
    plot.title = element_text(size = 14, hjust = 0.5),
    legend.title = element_blank(),
    legend.text = element_text(size = 10),
    legend.position = "right",
    legend.background = element_blank(),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12)) +
  scale_color_manual(values = chisp4)+
  stat_ellipse(aes(color = cluster)) +
  stat_stars(aes(color = cluster), show.legend = T) +
  xlab("PC1 (22.6%)") +
  ylab("PC2 (17.3%)") +
  labs(color = "Microbiome Profile")

p1

#looks the same!! so we can use these PC% in our figure above

#Alex included permanova by cluster in his R code but we don't need this; will delete from final version
#Create OTU table
# otu <- as.data.frame(otu_table(chi.spec_clr, taxa_are_rows=TRUE))
# #Need species in columns and observations in rows: transpose using t() function and save as a dataframe
#   #Source: https://github.com/edamame-course/2015-tutorials/blob/master/final/Ashley_Intro_to_R.md
# otu_trans <- data.frame(t(otu))
# child <- data.frame(sample_data(chi.spec_clr))
# #Calculate distance and save as a matrix
# BC.dist=vegdist(otu_trans, method="euclidean")
# 
# adonis2(BC.dist ~ hiv + age + cluster, data = sampleDF, permutations = 1000, by = "margin")
#   #significant association between beta-diversity and age (p=0.028) and cluster (p<0.001); HIV trend but not significant p=0.099)
# dispr <- vegan::betadisper(BC.dist, sampleDF$hiv)
# dispr
# 
# boxplot(dispr, main = "", xlab = "")
# permutest(dispr)
# #the average distance of each group member to the centroid DIFFERS by group (I assume based on avg distance to median produced by betadisper command + the permutest P value of 0.018); does this mean that part of my results are explained by the different distances within each HIV category? 

#do our clusters associate with any of our demographic variables?
#age by cluster
ggplot(sampleDF, aes(x=cluster, y=age)) +
  geom_boxplot(fill=chisp4) +
  xlab('Cluster') + 
  ylab('Age (Months)') +
  theme_classic()

#HIV category by cluster
#you don't have to manually create frequencies; use stat = "count" and get rid of your y= in aes
#Create new category of HIV to match our prior figure labels:
sampleDF$hiv2 <- NA
sampleDF$hiv2 [sampleDF$hiv == "Infected"] <- "CLWH"
sampleDF$hiv2 [sampleDF$hiv == "Exposed Uninfected"] <- "HEU children"
sampleDF$hiv2 [sampleDF$hiv == "Unexposed"] <- "HUU children"
table(sampleDF$hiv2)
#matches up with table(relative_df$hiv)
sampleDF$hiv2 <- as.factor(sampleDF$hiv2)
sampleDF$hiv2 <- reorder(sampleDF$hiv2, new.order=c("CLWH", "HEU children", "HUU children"))

#create plot
hiv_clust <- ggplot(sampleDF, aes(fill=hiv2, x=cluster)) + geom_bar(stat= "count", position = "fill", width = 0.9) +
  scale_fill_manual(values = c('#800000FF','#155F83FF', '#FFA319FF')) +
  # scale_y_continuous(labels = waiver()) +  
  scale_x_discrete(labels=xlab) +
  labs(title=" ", x="Microbiome profile", y="Proportion of children", fill = "HIV status")+
  theme_classic() +
  theme(
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12))

#it looks like cluster 2 has a lot more CLWH; will do an analysis comparing cluster 2 to all other clusters by HIV status

#save for ease of review; if you include in manuscript, will need to save as an eps file (sample code below)
png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/HIV_by_clust.png",
    width = 12, height = 9, units = 'in', res = 600)
hiv_clust
dev.off()

# #save as .eps file to comply with Lancet Microbe requirements
# ggsave(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/FILENAMEHERE.eps", width = 7, height = 3.5, units = "in")
# p
# dev.off()

#Are there any other variables we should look at visually? What about wood and antibiotics? Not signif associated below but it makes sense that they could affect microbiome composition
sampleDF$wood2 <- NA
sampleDF$wood2 [sampleDF$wood == "0"] <- "No"
sampleDF$wood2 [sampleDF$wood == "1"] <- "Yes"
table(sampleDF$wood2)
#matches up with table(relative_df$hiv)
sampleDF$wood2 <- as.factor(sampleDF$wood2)
sampleDF$wood2 <- reorder(sampleDF$wood2, new.order=c("Yes", "No"))
wood_clust <- ggplot(sampleDF, aes(fill=wood2, x=cluster)) + geom_bar(stat = "count", position = "fill", width = 0.9) + 
  scale_fill_manual(values = c('#800000FF','#155F83FF'))+
  scale_x_discrete(labels=xlab) +
  labs(title=" ", x="Microbiome profile", y="Proportion of children", fill = "Wood smoke exposure")+
  theme_classic() +
  theme(
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12))

wood_clust
#can try 2 comparisons: 1+5 vs 2-4, and 2 vs all other clusters 

class(sampleDF$abx)
sampleDF$abx <- as.factor(sampleDF$abx)
sampleDF$abx <- reorder(sampleDF$abx, new.order=c("Yes", "No"))
abx_clust <- ggplot(sampleDF, aes(fill=abx, x=cluster)) + geom_bar(stat = "count", position = "fill", width = 0.9) + 
  scale_fill_manual(values = c('#800000FF','#155F83FF'))+
  scale_x_discrete(labels=xlab) +
  labs(title=" ", x="Microbiome profile", y="Proportion of children", fill = "Antibiotic exposure")+
  theme_classic() +
  theme(
    legend.text = element_text(size = 10),
    legend.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12))

abx_clust
#if we group 1 and 5 together and 2-4 together, what does that look like?

#Since we are doing all these split comparisons based on our bar plot results, we will save these using cowplot in case we want to include them as a supplemental figure
fig_barclust <- plot_grid(hiv_clust, wood_clust, abx_clust, labels = c('A', 'B', 'C'), align = "h", axis = "b", label_size = 12)
fig_barclust

#save as .eps file to comply with Lancet Microbe requirements
ggsave(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/barclust_combined.eps", width = 9, height = 5, units = "in")
fig_barclust
dev.off()
```

- Statistical testing of demographic variables by biotype (as done in CID paper); will use same variables as used in Table 1 (plus HIV). Included in Table (table # TBD for manuscript, likely supplemental)

```{r}
#Age
tapply(sampleDF$age, sampleDF$cluster, summary)
kruskal.test(sampleDF$age, sampleDF$cluster) #p=0.04

#Sex
table(sampleDF$sex, sampleDF$cluster)
prop.table(table(sampleDF$sex, sampleDF$cluster), 2)
summary(table(sampleDF$sex, sampleDF$cluster))

#HIV status!
table(sampleDF$hiv, sampleDF$cluster)
prop.table(table(sampleDF$hiv, sampleDF$cluster), 2)
summary(table(sampleDF$hiv, sampleDF$cluster))
fisher.test(sampleDF$hiv, sampleDF$cluster)
#received following error: Error in fisher.test(sampleDF$hiv, sampleDF$cluster) : 
  #FEXACT error 7(location). LDSTP=18630 is too small for this problem,
 # (pastp=64.7107, ipn_0:=ipoin[itp=201]=9, stp[ipn_0]=62.0229).
#Increase workspace or consider using 'simulate.p.value=TRUE'
fisher.test(sampleDF$hiv, sampleDF$cluster, simulate.p.value = TRUE)

#Maternal age
tapply(sampleDF$mat_age2, sampleDF$cluster, summary)
kruskal.test(sampleDF$mat_age2, sampleDF$cluster)

#Season
table(sampleDF$season, sampleDF$cluster)
prop.table(table(sampleDF$season, sampleDF$cluster), 2)
summary(table(sampleDF$season, sampleDF$cluster)) #p=0.008!

#Maternal education
table(sampleDF$mat_educ2)
table(sampleDF$mat_educ2, sampleDF$cluster)
prop.table(table(sampleDF$mat_educ2, sampleDF$cluster), 2)
# summary(table(sampleDF$mat_educ2, sampleDF$cluster))
fisher.test(sampleDF$mat_educ2, sampleDF$cluster)

#Electricity
table(sampleDF$elec, sampleDF$cluster)
prop.table(table(sampleDF$elec, sampleDF$cluster), 2)
# summary(table(sampleDF$elec, sampleDF$cluster))
fisher.test(sampleDF$elec, sampleDF$cluster)

#Wood 
table(sampleDF$wood, sampleDF$cluster)
prop.table(table(sampleDF$wood, sampleDF$cluster), 2)
summary(table(sampleDF$wood, sampleDF$cluster))

#Num household members
tapply(sampleDF$hhsize, sampleDF$cluster, summary)
kruskal.test(sampleDF$hhsize, sampleDF$cluster)

#antibiotics
table(sampleDF$abx) #24 children received abx
table(sampleDF$abx, sampleDF$cluster)
prop.table(table(sampleDF$abx, sampleDF$cluster), 2)
# summary(table(sampleDF$abx, sampleDF$cluster))
fisher.test(sampleDF$abx, sampleDF$cluster)

#URI in past 1 month
table(sampleDF$uri_recent) #59 kids with URI sx
table(sampleDF$uri_rec2, sampleDF$cluster)
prop.table(table(sampleDF$uri_rec2, sampleDF$cluster), 2)
summary(table(sampleDF$uri_rec2, sampleDF$cluster))

#PCV doses
sampleDF$pcv3 <- NA
sampleDF$pcv3 [sampleDF$pcv == 0 | sampleDF$pcv == 1 | sampleDF$pcv == 2] <- "No"
sampleDF$pcv3 [sampleDF$pcv == 3] <- "Yes"
table(sampleDF$pcv3)
table(sampleDF$pcv) #confirms numbers match up
table(sampleDF$pcv3, sampleDF$cluster)
prop.table(table(sampleDF$pcv3, sampleDF$cluster), 2)
# summary(table(sampleDF$pcv3, sampleDF$cluster))
fisher.test(sampleDF$pcv3, sampleDF$cluster)

#HiB
sampleDF$dpt3 <- NA
sampleDF$dpt3 [sampleDF$dpt == 0 | sampleDF$dpt == 1 | sampleDF$dpt == 2] <- "No"
sampleDF$dpt3 [sampleDF$dpt == 3] <- "Yes"
table(sampleDF$dpt3)
table(sampleDF$dpt) #confirms numbers match up
table(sampleDF$dpt3, sampleDF$cluster)
prop.table(table(sampleDF$dpt3, sampleDF$cluster), 2)
# summary(table(sampleDF$dpt3, sampleDF$cluster))
fisher.test(sampleDF$dpt3, sampleDF$cluster)
```

Combining profiles to look for specific associations given the barplots above for HIV status, wood smoke exposure, and antibiotic exposure:

```{r}
sampleDF$clust15 <- NA
sampleDF$clust15 [sampleDF$cluster == "1" | sampleDF$cluster == "5"] <- "C-D"
sampleDF$clust15 [sampleDF$cluster == "2" | sampleDF$cluster == "3" |sampleDF$cluster == "4"] <- "Other"
table(sampleDF$clust15)

sampleDF$clust2 <- NA
sampleDF$clust2 [sampleDF$cluster == "2"] <- "SP-HI"
sampleDF$clust2 [sampleDF$cluster == "1" | sampleDF$cluster == "3" |sampleDF$cluster == "4" |sampleDF$cluster == "5"] <- "Other"
table(sampleDF$clust2)

#HIV 
#by cluster 2
table(sampleDF$hiv, sampleDF$clust2)
prop.table(table(sampleDF$hiv, sampleDF$clust2), 2)
summary(table(sampleDF$hiv, sampleDF$clust2)) #P=0.013!!!

#by cluster 1+5 
table(sampleDF$hiv, sampleDF$clust15)
prop.table(table(sampleDF$hiv, sampleDF$clust15), 2)
summary(table(sampleDF$hiv, sampleDF$clust15)) #no significant association

#wood smoke 
#by cluster 2
table(sampleDF$wood, sampleDF$clust2)
prop.table(table(sampleDF$wood, sampleDF$clust2), 2)
summary(table(sampleDF$wood, sampleDF$clust2)) #P = 0.045

#by cluster 1+5 
table(sampleDF$wood, sampleDF$clust15)
prop.table(table(sampleDF$wood, sampleDF$clust15), 2)
summary(table(sampleDF$wood, sampleDF$clust15)) #P = 0.014

#antibiotics
#by cluster 2
table(sampleDF$abx, sampleDF$clust2)
prop.table(table(sampleDF$abx, sampleDF$clust2), 2)
summary(table(sampleDF$abx, sampleDF$clust2)) #P = 0.047 but may be incorrect (some n < 10 but not <5; has cutoff changed?)
fisher.test(sampleDF$abx, sampleDF$clust2) #P = 0.08

#by cluster 1+5 
table(sampleDF$abx, sampleDF$clust15)
prop.table(table(sampleDF$abx, sampleDF$clust15), 2)
summary(table(sampleDF$abx, sampleDF$clust15)) #P = 0.008
```

- Multivariable analyses of associations between clinical variables and microbiome profiles.

A priori, we would expect antibiotic exposure and URI sx to associate with both HIV and microbiome composition (even though we do not see this in our demographics table). Wood smoke shouldn't be affected by HIV status (except potentially as proxy for low SES --> less access to healthcare but this is a bit of a stretch as 61% of our study participants were exposed to wood smoke). Thus, we will adjust for age, abx exposure, and URI sx when looking for associations between HIV and microbiome profile. We need binary outcomes for multivariable logistic regression, so will look at cluster 2 yes/no and clusters 1/5 yes/no by HIV status. Can also look at clusters using multinomial logistic regression? Run and confirm with MK. 

```{r}
#Need to create binary 0/1 variables for cluster 2 and cluster 1/5 vars

sampleDF$clust2b <- NA
sampleDF$clust2b [sampleDF$clust2 == "SP-HI"] <- 1
sampleDF$clust2b [sampleDF$clust2 == "Other"] <- 0
table(sampleDF$clust2b)

sampleDF$clust15b <- NA
sampleDF$clust15b [sampleDF$clust15 == "C-D"] <- 1
sampleDF$clust15b [sampleDF$clust15 == "Other"] <- 0
table(sampleDF$clust15b)

sampleDF$hiv <- as.factor(sampleDF$hiv)
sampleDF$hiv <- relevel(sampleDF$hiv, ref = "Unexposed")

sampleDF$abx <- as.factor(sampleDF$abx)
sampleDF$abx <- relevel(sampleDF$abx, ref = "No")

sampleDF$uri_rec2 <- as.factor(sampleDF$uri_rec2)
sampleDF$uri_rec2 <- relevel(sampleDF$uri_rec2, ref = "No")

summary(mylogit <- glm(clust2b ~ hiv + age + abx + uri_rec2, data = sampleDF, family = "binomial")) #significant assoc b/w cluster 2 and HIV infection

#we adjust all other analyses for season and wood smoke exposure as well, so for uniformity will do here: 
class(sampleDF$wood2)
sampleDF$wood2 <- relevel(sampleDF$wood2, ref = "No")

sampleDF$season <- as.factor(sampleDF$season)
sampleDF$season <- relevel(sampleDF$season, ref = "Dry")

summary(mylogit <- glm(clust2b ~ hiv + age + abx + uri_rec2 + season + wood2, data = sampleDF, family = "binomial")) #significant assoc remains b/w cluster 2 and HIV infection
exp(mylogit$coefficients) #OR (95% CI) for CLWH: 5.31 (1.66, 20.75)
exp(confint(mylogit))

###MULTINOMIAL LOGISTIC REGRESSION###
#To look at association b/w HIV and all clusters (unlikely to show anything given small n but we will try)
#Using code from our PCV-13 serotype analysis published in PLOS One in 2021
library(nnet)
sampleDF$cluster <- relevel(sampleDF$cluster, ref = "1")
summary(test1 <- multinom(cluster ~ hiv + age, data = sampleDF))
z1 <- summary(test1)$coefficients/summary(test1)$standard.errors
z1
#Calculate p-values using Wald tests (here z-tests).
#2-tailed z test
p1 <- (1 - pnorm(abs(z1), 0, 1)) * 2
p1 #HIV infection a/w cluster 2 (p=0.017) and age a/w cluster 3 (p=0.007)

#The exponentiated regression coefficients are relative risk ratios for a unit change in the predictor variable
## extract the coefficients from the model and exponentiate
exp(coef(test1))
#Obtaining 95% CI for our RR
exp(confint(test1))
```
*Summary of multivariable analysis*
**In a multivariable logistic regression model adjusting for all covariables specified in our methods with presence/absence of cluster 2 as the outcome of interest, HIV infection was associated with presence of cluster 2 (S. pneumo - H. flu); OR (95% CI): 5.31 (1.66, 20.75).**

**In multinomial logistic regression model with cluster membership as the outcome, cluster 1 set as the reference, and HIV status and age as covariables, HIV was significantly associated with the presence of cluster 2; relative risk ratio (95% CI) 5.10 (1.34, 19.36) ; p=0.017. Age was significantly associated with the presence of cluster 3; relative risk ratio (95% CI) 0.94 (0.90, 0.98) ; p=0.007.**

- Microbiome factors: did alpha diversity differ by cluster? What species comprised each cluster?

```{r}
Shannon = estimate_richness(chi.spec, measures = "Shannon")%>%
  cbind(., sampleDF, by = "names") #used Alex's code but this gives you a new dataframe to use called "Shannon"

tapply(Shannon$Shannon, Shannon$cluster, summary)
kruskal.test(Shannon$Shannon, Shannon$cluster) #P<0.001

shan <- ggplot(Shannon, aes(x=cluster, y=Shannon, fill=cluster)) + 
  geom_boxplot() + labs(x="Microbiome profile", y = "Shannon index")+
  scale_fill_manual(values=chisp4) +
  theme_classic() +
  theme(
    legend.text = element_text(size = 10),
    legend.position = "none",
    legend.title = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.y = element_text(size = 12),
    axis.title.x = element_text(size = 12))

#save for ease of review; if you include in manuscript, will need to save as an eps file (sample code below)
png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/SDI_by_clust.png",
    width = 12, height = 9, units = 'in', res = 600)
shan
dev.off()

#save as .eps file to comply with Lancet Microbe requirements
ggsave(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/SDI_by_clust.eps", width = 7, height = 3.5, units = "in")
shan
dev.off()

```

```{r}
#Cluster composition
sample_data(chi.spec)$cluster = as.factor(data.cluster)

psC1 = subset_samples(chi.spec, sample_data(chi.spec)$cluster == 1)
speciesDF = as.data.frame(cbind((otu_table(psC1, taxa_are_rows = FALSE)), tax_table(psC1)))
rownames(speciesDF) = NULL
speciesDF$Kingdom = NULL
speciesDF$Phylum=NULL
speciesDF$Class=NULL
speciesDF$Order=NULL
speciesDF$Family=NULL
row.names(speciesDF) <-  speciesDF$Species #keep getting an error message: "Warning: non-unique value when setting 'row.names': NA;g;s
  #Error in `.rowNamesDF<-`(x, value = value) : 
  #duplicate 'row.names' are not allowed
#may be due to the unnamed species in the table; will remove them and try again
speciesDF$Species <- gsub(";", NA, speciesDF$Species)
speciesDF <- speciesDF %>% drop_na(Species) #Go from 6709 --> 6162 rows
speciesDF$Genus=NULL
speciesDF$Species = NULL
speciesDF = mutate_all(speciesDF, function(x) as.numeric(as.character(x)))

speciesDF$C1 = rowMeans(speciesDF)

AvgDF1 = speciesDF$C1

#now repeat this process for clusters 2-5, saving AvgDF2-5 in the process so we can bind them all together at the end

psC1 = subset_samples(chi.spec, sample_data(chi.spec)$cluster == 2)
speciesDF = as.data.frame(cbind((otu_table(psC1, taxa_are_rows = FALSE)), tax_table(psC1)))
speciesDF$Species <- gsub(";", NA, speciesDF$Species)
speciesDF <- speciesDF %>% drop_na(Species) #Go from 6709 --> 6162 rows
row.names(speciesDF) <-  speciesDF$Species 
speciesDF$Kingdom = NULL
speciesDF$Phylum=NULL
speciesDF$Class=NULL
speciesDF$Order=NULL
speciesDF$Family=NULL
speciesDF$Genus=NULL
speciesDF$Species = NULL
speciesDF = mutate_all(speciesDF, function(x) as.numeric(as.character(x)))
speciesDF$C1 = rowMeans(speciesDF)
AvgDF2 = speciesDF$C1

psC1 = subset_samples(chi.spec, sample_data(chi.spec)$cluster == 3)
speciesDF = as.data.frame(cbind((otu_table(psC1, taxa_are_rows = FALSE)), tax_table(psC1)))
speciesDF$Species <- gsub(";", NA, speciesDF$Species)
speciesDF <- speciesDF %>% drop_na(Species) #Go from 6709 --> 6162 rows
row.names(speciesDF) <-  speciesDF$Species 
speciesDF$Kingdom = NULL
speciesDF$Phylum=NULL
speciesDF$Class=NULL
speciesDF$Order=NULL
speciesDF$Family=NULL
speciesDF$Genus=NULL
speciesDF$Species = NULL
speciesDF = mutate_all(speciesDF, function(x) as.numeric(as.character(x)))
speciesDF$C1 = rowMeans(speciesDF)
AvgDF3 = speciesDF$C1

psC1 = subset_samples(chi.spec, sample_data(chi.spec)$cluster == 4)
speciesDF = as.data.frame(cbind((otu_table(psC1, taxa_are_rows = FALSE)), tax_table(psC1)))
speciesDF$Species <- gsub(";", NA, speciesDF$Species)
speciesDF <- speciesDF %>% drop_na(Species) #Go from 6709 --> 6162 rows
row.names(speciesDF) <-  speciesDF$Species 
speciesDF$Kingdom = NULL
speciesDF$Phylum=NULL
speciesDF$Class=NULL
speciesDF$Order=NULL
speciesDF$Family=NULL
speciesDF$Genus=NULL
speciesDF$Species = NULL
speciesDF = mutate_all(speciesDF, function(x) as.numeric(as.character(x)))
speciesDF$C1 = rowMeans(speciesDF)
AvgDF4 = speciesDF$C1

psC1 = subset_samples(chi.spec, sample_data(chi.spec)$cluster == 5)
speciesDF = as.data.frame(cbind((otu_table(psC1, taxa_are_rows = FALSE)), tax_table(psC1)))
speciesDF$Species <- gsub(";", NA, speciesDF$Species)
speciesDF <- speciesDF %>% drop_na(Species) #Go from 6709 --> 6162 rows
row.names(speciesDF) <-  speciesDF$Species 
speciesDF$Kingdom = NULL
speciesDF$Phylum=NULL
speciesDF$Class=NULL
speciesDF$Order=NULL
speciesDF$Family=NULL
speciesDF$Genus=NULL
speciesDF$Species = NULL
speciesDF = mutate_all(speciesDF, function(x) as.numeric(as.character(x)))
speciesDF$C1 = rowMeans(speciesDF)
AvgDF5 = speciesDF$C1

#Now combine all your row means and pull out the 10 most common species for consistency with our other species barplots
AvgDF = cbind(AvgDF1, AvgDF2, AvgDF3, AvgDF4, AvgDF5) %>%
  data.frame(.)
rownames(AvgDF) = rownames(speciesDF)
AvgDF$Avg = rowMeans(AvgDF)

#taking the 10 most common based on the averages across profiles
fig = top_n(AvgDF, 10, Avg) 
Other = 1 - colSums(fig)
fig = rbind(fig, Other)
rownames(fig)[rownames(fig) == "11"] <- "Other"
fig$tax = rownames(fig)

fig = dplyr::select(fig, -Avg) %>%
  dplyr::rename('1' = AvgDF1,
                '2' = AvgDF2,
                '3' = AvgDF3,
                '4' = AvgDF4,
                '5' = AvgDF5)

library(reshape2)
f = melt(fig) 

f$tax = factor(f$tax, levels=c("Corynebacterium accolens", "Corynebacterium propinquum", "Corynebacterium pseudodiphtheriticum", "Dolosigranulum pigrum","Haemophilus influenzae","Moraxella catarrhalis", "Moraxella lincolnii", "Moraxella nonliquefaciens", "Staphylococcus aureus","Streptococcus pneumoniae","Other"))

#rename tax so it looks nicer in the table legend
colnames(f)[colnames(f) == "tax"] <- "Species"

subject_plot3 <- ggplot(f[order(f$Species, decreasing = TRUE),], aes(x=variable, y=value, fill=Species)) + 
  geom_bar(stat="identity", position="fill") + theme_classic() + 
  theme(legend.position="right", 
  legend.text=element_text(size=10, face="italic"),
  axis.title.y = element_text(size=12, margin=margin(0,20,0,0)), axis.text.y = element_text(size=10), 
  axis.title.x = element_text(size=12), axis.text.x = element_text(size=10, vjust = 1, hjust = 1, colour = "black")) + 
  scale_fill_manual(values = chisp2) +
  # scale_x_discrete(labels=c("No", "Yes")) +
  xlab("Microbiome profile") + ylab("Mean relative abundance") 

#save for ease of review; if you include in manuscript, will need to save as an eps file (sample code below)
png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/cluster_rel_abund.png",
    width = 12, height = 9, units = 'in', res = 600)
subject_plot3
dev.off()

#NOW: use cowplot to combine our PCoA plot and composition bar plot into one figure
fig5 <- plot_grid(clust, subject_plot3, labels = c('A', 'B'), align = "h", axis = "b", label_size = 12, rel_widths = c(1, 1.5))
fig5

#save as .eps file to comply with Lancet Microbe requirements
ggsave(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/fig5_clust.eps", width = 11, height = 3.5, units = "in")
fig5
dev.off()
```

What do our clusters look like by immune status among CLWH?

We originally repeated the clustering process with only CLWH and ended up with 6 clusters, but from d/w MK we should complete all sub-analyses using our original 5 clusters. Thus, all of the CLWH-specific clustering code was deleted from this version and we will start with the csv file we saved previously that includes a cluster variable. We will subset out our CLWH, generate the relevant variables (vL, CD4), and look for associations between HIV-specific variables and clusters among CLWH.

```{r}
sampleDF <- read.csv("/Users/swetapatel/OneDrive - Duke University/Fogarty coding/metadata_clust.csv")

#subset out CLWH
chi_hiv <- subset(sampleDF, hiv2 == "CLWH") #so we can use our original code for variable creation

#Now create variables for viral load and CD4
#I want the most recent viral load values for my analysis. Will try creating a new variable to ID which value is more recent first:
#missing 3 vl1 and 14vl2's
chi_hiv$newest_vL <- NA
chi_hiv$newest_vL [chi_hiv$child_vl1_weeks < chi_hiv$child_vl2_weeks] <- 1
chi_hiv$newest_vL [chi_hiv$child_vl2_weeks < chi_hiv$child_vl1_weeks] <- 2
chi_hiv$newest_vL [chi_hiv$child_vl2_weeks < 0] <- 1  #we want to include the viral loads collected BEFORE enrollment where possible
chi_hiv$newest_vL [is.na(chi_hiv$child_vl_2)] <- 1    #if we are missing vl_2, we will use vl_1
chi_hiv$newest_vL [is.na(chi_hiv$child_vl_1) & is.na(chi_hiv$child_vl_2)] <- NA
table(chi_hiv$newest_vL)

#Next, can we pull the viral load that was most recent using our newest_vL variable?
  #source: https://stackoverflow.com/questions/67944727/creating-new-variable-by-selecting-column-based-on-value-of-another-column
  #Need to do this with rows that have values (aka need to exclude the NA viral load children for this to work)
#For future phyloseq analyses: will need to remove B-04, B-07, B-52
chi_viral <- subset(chi_hiv, !is.na(newest_vL))
chi_viral$Var1 <- chi_viral$child_vl_1
chi_viral$Var2 <- chi_viral$child_vl_2

chi_viral <- chi_viral %>% rowwise() %>%
  mutate(newest_vlnum = get(paste0('Var', newest_vL)))
#now we have a dataframe of the 41 children with viral load measurements and 1 column containing the most recent viral loads for each
summary(chi_viral$newest_vlnum)
table(chi_viral$newest_vlnum) #27 with viral suppression, 14 without viral suppression

#make new variable for viral suppression or not, with vL < 400 = suppressed
chi_viral$vl_suppr <- NA
chi_viral$vl_suppr [chi_viral$newest_vlnum < 400] <- "1"
chi_viral$vl_suppr [chi_viral$newest_vlnum >= 400] <- "0"
table(chi_viral$vl_suppr)

#REPEAT the above steps to get date associated with most recent viral load, most recent CD4, and date a/w most recent CD4
#Viral load collection date
chi_viral$Var1 <- chi_viral$child_vl1_weeks
chi_viral$Var2 <- chi_viral$child_vl2_weeks

chi_viral <- chi_viral %>% rowwise() %>%
  mutate(newest_vldate = get(paste0('Var', newest_vL)))   #now have info for when vL were checked in relation to enrollment

summary(chi_viral$newest_vldate)

chi_viral <- within(chi_viral, rm(Var1, Var2))

#CD4
  #missing CD4 data for B-45 and B-52
  #will focus on percentages since this is what is presented for kids
chi_hiv$newest_cd4 <- NA
chi_hiv$newest_cd4 [chi_hiv$chi_cd4_weeks1 < chi_hiv$chi_cd4_weeks2] <- 1
chi_hiv$newest_cd4 [chi_hiv$chi_cd4_weeks2 < chi_hiv$chi_cd4_weeks1] <- 2
chi_hiv$newest_cd4 [chi_hiv$chi_cd4_weeks2 < 0] <- 1  #we want to include the viral loads collected BEFORE enrollment where possible
chi_hiv$newest_cd4 [is.na(chi_hiv$chi_cd4_perc_2)] <- 1    #if we are missing cd4_2, we will use cd4_1
chi_hiv$newest_cd4 [is.na(chi_hiv$chi_cd4_perc_1)] <- 2    #one child is missing cd4_1 but has cd4_2
chi_hiv$newest_cd4 [is.na(chi_hiv$chi_cd4_perc_1) & is.na(chi_hiv$chi_cd4_perc_2)] <- NA
table(chi_hiv$newest_cd4)

#create new dataframe without B-45 and B-52 (aka new df with children missing CD4 data removed)
chi_cd4 <- subset(chi_hiv, !is.na(newest_cd4))
chi_cd4$Var1 <- chi_cd4$chi_cd4_perc_1
chi_cd4$Var2 <- chi_cd4$chi_cd4_perc_2

chi_cd4 <- chi_cd4 %>% rowwise() %>%
  mutate(newest_cd4perc = get(paste0('Var', newest_cd4)))

summary(chi_cd4$newest_cd4perc)
table(chi_cd4$newest_cd4perc)

#make new variable for immune competent CD4 or not, with CD4 percentage >=25% = immune competent
  #d/w MK re: potentially adding a cutoff at 15% for immunosuppression, but we only have 2 kids with CD4% < 15 so will stay with 25% binary for now
chi_cd4$cd4nL <- NA
chi_cd4$cd4nL [chi_cd4$newest_cd4perc >=25] <- "1"
chi_cd4$cd4nL [chi_cd4$newest_cd4perc < 25] <- "0"
table(chi_cd4$cd4nL) 

#arvs
table(chi_hiv$child_arv)
table(chi_hiv$child_arv_meds)
```

- Do any of our clusters associate with age or HIV-specific covariables (viral suppression, cd4 category, TMP-SMX use, abx use)?

Will create plots first to visually assess for associations.

```{r}
#do our clusters associate with any of our demographic variables?
#age by cluster
chi_hiv$cluster <- as.factor(chi_hiv$cluster)
a <- ggplot(chi_hiv, aes(x=cluster, y=age)) +
  geom_boxplot(fill=chisp4) +
  xlab('Cluster') + 
  ylab('Age (Months)') +
  theme_classic()

#viral suppression by cluster
b <- ggplot(chi_viral, aes(fill=vl_suppr, x=cluster)) + geom_bar(stat = "count", position = "fill", width = 0.9) + 
  scale_fill_manual(values = c('#800000FF','#155F83FF'))+
  xlab('Cluster')+
  theme_classic()

#CD4 category by cluster
c <- ggplot(chi_cd4, aes(fill=cd4nL, x=cluster)) + geom_bar(stat = "count", position = "fill", width = 0.9) + 
  scale_fill_manual(values = c('#800000FF','#155F83FF'))+
  xlab('Cluster')+
  theme_classic()

#TMP-SMX use by cluster
chi_hiv$tmpsmx <- NA
chi_hiv$tmpsmx [chi_hiv$child_tmpsmx == 1] <- "Yes"
chi_hiv$tmpsmx[chi_hiv$child_tmpsmx == 2] <- "No"
table(chi_hiv$tmpsmx)

d <- ggplot(chi_hiv, aes(fill=tmpsmx, x=cluster)) + geom_bar(stat = "count", position = "fill", width = 0.9) + 
  scale_fill_manual(values = c('#800000FF','#155F83FF'))+
  xlab('Cluster')+
  theme_classic()

#abx use by cluster
e <- ggplot(chi_hiv, aes(fill=abx, x=cluster)) + geom_bar(stat = "count", position = "fill", width = 0.9) +
  scale_fill_manual(values = c('#800000FF','#155F83FF'))+
  xlab('Cluster')+
  theme_classic()

#save as an image for reference while we do additional analyses:
clust_hivcomb <- plot_grid(a,b,c,d,e, labels = "AUTO", nrow = 3, ncol = 2, align = "hv", axis = "b")

clust_hivcomb

png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/clwh_clust5bar.png",
    width = 12, height = 9, units = 'in', res = 600)
clust_hivcomb
dev.off()

#Visual trends: cluster 3 has the highest number of viremic kids. Cluster 5 only has immunocompetent children, and clusters 1 and 4 have the highest number of virally suppressed kids and the second highest number of immunocompetent kids. We will check comparisons of 3 vs others, 1-4 vs others, 2-3 vs others, and 5 vs others. Will also look at 1-5 and 1 only for CD4 since these are our Coryne heavy groups (and 1 has the most C. pseudodiphtheriticum)

#create these variables (will make binary in anticipation of logistic regression analyses)
#create in both chi_viral and chi_cd4 dataframes (since we have a different N in each)
chi_viral$clust1 <- NA
chi_viral$clust1 [chi_viral$cluster == "1"] <- 1
chi_viral$clust1[chi_viral$cluster != "1"] <- 0
table(chi_viral$clust1)

chi_viral$clust3 <- NA
chi_viral$clust3 [chi_viral$cluster == "3"] <- 1
chi_viral$clust3[chi_viral$cluster != "3"] <- 0
table(chi_viral$clust3)

chi_viral$clust5 <- NA
chi_viral$clust5 [chi_viral$cluster == "5"] <- 1
chi_viral$clust5[chi_viral$cluster != "5"] <- 0
table(chi_viral$clust5)

chi_viral$clust23 <- NA
chi_viral$clust23 [chi_viral$cluster == "2" | chi_viral$cluster == "3"] <- 1
chi_viral$clust23[chi_viral$cluster == "1" | chi_viral$cluster == "4" | chi_viral$cluster == "5"] <- 0
table(chi_viral$clust23)

chi_viral$clust14 <- NA
chi_viral$clust14 [chi_viral$cluster == "1" | chi_viral$cluster == "4"] <- 1
chi_viral$clust14[chi_viral$cluster == "2" | chi_viral$cluster == "3" | chi_viral$cluster == "5"] <- 0
table(chi_viral$clust14)

chi_viral$clust15 <- NA
chi_viral$clust15 [chi_viral$cluster == "1" | chi_viral$cluster == "5"] <- 1
chi_viral$clust15 [chi_viral$cluster == "2" | chi_viral$cluster == "3" |chi_viral$cluster == "4"] <- 0
table(chi_viral$clust15)

chi_cd4$clust1 <- NA
chi_cd4$clust1 [chi_cd4$cluster == "1"] <- 1
chi_cd4$clust1[chi_cd4$cluster != "1"] <- 0
table(chi_cd4$clust1)

chi_cd4$clust3 <- NA
chi_cd4$clust3 [chi_cd4$cluster == "3"] <- 1
chi_cd4$clust3[chi_cd4$cluster != "3"] <- 0
table(chi_cd4$clust3)

chi_cd4$clust5 <- NA
chi_cd4$clust5 [chi_cd4$cluster == "5"] <- 1
chi_cd4$clust5[chi_cd4$cluster != "5"] <- 0
table(chi_cd4$clust5)

chi_cd4$clust23 <- NA
chi_cd4$clust23 [chi_cd4$cluster == "2" | chi_cd4$cluster == "3"] <- 1
chi_cd4$clust23[chi_cd4$cluster == "1" | chi_cd4$cluster == "4" | chi_cd4$cluster == "5"] <- 0
table(chi_cd4$clust23)

chi_cd4$clust14 <- NA
chi_cd4$clust14 [chi_cd4$cluster == "1" | chi_cd4$cluster == "4"] <- 1
chi_cd4$clust14[chi_cd4$cluster == "2" | chi_cd4$cluster == "3" | chi_cd4$cluster == "5"] <- 0
table(chi_cd4$clust14)

chi_cd4$clust15 <- NA
chi_cd4$clust15 [chi_cd4$cluster == "1" | chi_cd4$cluster == "5"] <- 1
chi_cd4$clust15 [chi_cd4$cluster == "2" | chi_cd4$cluster == "3" |chi_cd4$cluster == "4"] <- 0
table(chi_cd4$clust15)
```

Next, statistical testing to identify demographic differences by cluster among CLWH

```{r}
table(chi_hiv$cluster)

###DEMOGRAPHIC DIFFERENCES BY CLUSTER AMONG CLWH
#Age
tapply(chi_hiv$age, chi_hiv$cluster, summary)
kruskal.test(chi_hiv$age, chi_hiv$cluster) #p=0.16

#Sex
table(chi_hiv$sex, chi_hiv$cluster)
prop.table(table(chi_hiv$sex, chi_hiv$cluster), 2)
fisher.test(chi_hiv$sex, chi_hiv$cluster)

#TMP-SMX use
table(chi_hiv$tmpsmx, chi_hiv$cluster)
prop.table(table(chi_hiv$tmpsmx, chi_hiv$cluster), 2)
fisher.test(chi_hiv$tmpsmx, chi_hiv$cluster)

#Abx use
table(chi_hiv$abx, chi_hiv$cluster)
prop.table(table(chi_hiv$abx, chi_hiv$cluster), 2)
fisher.test(chi_hiv$abx, chi_hiv$cluster)

#Viral suppression
table(chi_viral$vl_suppr, chi_viral$cluster)
prop.table(table(chi_viral$vl_suppr, chi_viral$cluster), 2)
fisher.test(chi_viral$vl_suppr, chi_viral$cluster)

#CD4 status #p=0.09
table(chi_cd4$cd4nL, chi_cd4$cluster)
prop.table(table(chi_cd4$cd4nL, chi_cd4$cluster), 2)
fisher.test(chi_cd4$cd4nL, chi_cd4$cluster)

#2 group analysis by CD4 and viral suppression status: 
#viral suppression
#by cluster 1: p=0.27
table(chi_viral$vl_suppr, chi_viral$clust1)
prop.table(table(chi_viral$vl_suppr, chi_viral$clust1), 2)
fisher.test(chi_viral$vl_suppr, chi_viral$clust1)

#by clusters 1&4: p = 0.02
table(chi_viral$vl_suppr, chi_viral$clust14)
prop.table(table(chi_viral$vl_suppr, chi_viral$clust14), 2)
fisher.test(chi_viral$vl_suppr, chi_viral$clust14)

#by clusters 1&5: p = 1 (not surprising based on bar plots)
table(chi_viral$vl_suppr, chi_viral$clust15)
prop.table(table(chi_viral$vl_suppr, chi_viral$clust15), 2)
fisher.test(chi_viral$vl_suppr, chi_viral$clust15)

#by cluster 3: p = 0.26
table(chi_viral$vl_suppr, chi_viral$clust3)
prop.table(table(chi_viral$vl_suppr, chi_viral$clust3), 2)
fisher.test(chi_viral$vl_suppr, chi_viral$clust3)

#by cluster 5: p=0.32
table(chi_viral$vl_suppr, chi_viral$clust5)
prop.table(table(chi_viral$vl_suppr, chi_viral$clust5), 2)
fisher.test(chi_viral$vl_suppr, chi_viral$clust5)

#low vs normal CD4%
#by cluster 1: p=0.25
table(chi_cd4$cd4nL, chi_cd4$clust1)
prop.table(table(chi_cd4$cd4nL, chi_cd4$clust1), 2)
fisher.test(chi_cd4$cd4nL, chi_cd4$clust1)

#by clusters 1&4: p = 0.08
table(chi_cd4$cd4nL, chi_cd4$clust14)
prop.table(table(chi_cd4$cd4nL, chi_cd4$clust14), 2)
fisher.test(chi_cd4$cd4nL, chi_cd4$clust14)

#by clusters 1&5: p = 0.06
table(chi_cd4$cd4nL, chi_cd4$clust15)
prop.table(table(chi_cd4$cd4nL, chi_cd4$clust15), 2)
fisher.test(chi_cd4$cd4nL, chi_cd4$clust15)

#by cluster 3: p = 0.28
table(chi_cd4$cd4nL, chi_cd4$clust3)
prop.table(table(chi_cd4$cd4nL, chi_cd4$clust3), 2)
fisher.test(chi_cd4$cd4nL, chi_cd4$clust3)

#by cluster 5: p=0.30
table(chi_cd4$cd4nL, chi_cd4$clust5)
prop.table(table(chi_cd4$cd4nL, chi_cd4$clust5), 2)
fisher.test(chi_cd4$cd4nL, chi_cd4$clust5)

#by cluster 2 or 3: p = 0.004
table(chi_cd4$cd4nL, chi_cd4$clust23)
prop.table(table(chi_cd4$cd4nL, chi_cd4$clust23), 2)
fisher.test(chi_cd4$cd4nL, chi_cd4$clust23)

#Will not do any multivariable testing because our sample size is too small
```

####Co-occurrence plots (aka network analysis) to characterize interspecies interactions/associations 

- Got reviewer request for the following: "I suspect you will have a multiple associations with higher Corynebacterium such as an intact immune system, and a negative association with Staph/Strep (which will be highly associated with CD4+ count). Please see co-occurence plots built with networks of spearman correlations (PMID: 30093571)."

PMID links to a paper by Leo Segal's group: https://erj.ersjournals.com/content/52/4/1800810.long#sec-2.
Their description of the network correlation methods is as follows: "Co-occurrence between most abundant bacterial genera (>1% relative abundance in at least one sample) were assessed using SparCC [30] with 20 iterations and 500 bootstrap replicates to eliminate correlations where significance was driven by outliers and visualised using Cytoscape v3.0.2 [31]. Only biomarkers that passed false discovery rate correction were used for this analysis [32]."
- code used in paper: https://github.com/segalmicrobiomelab/ntm_bronchiectasis_microbiome/blob/master/NTM.r --> this does not have any of the correlation network code, which is not helpful.

Found multiple SpiecEasi tutorials: 
1. https://biovcnet.github.io/_pages/NetworkScience_SparCC.nb.html (helps you run sparcc and generate file that you can plug into cytoscape)
2. https://mibwurrepo.github.io/Microbial-bioinformatics-introductory-course-Material-2018/inference-of-microbial-ecological-networks.html (looks like you can create your network diagram within R itself)
3. SpiecEasi package github (with newest code, looks like): 

Note: installing SpiecEasi on a mac was a beast and required the following steps (recording here in case I need to install another package requiring compliation in the future). Took ~2.5h troubleshooting.
1. Downloaded gfortran from CRAN: https://cran.r-project.org/bin/macosx/tools/
2. This defaults to storing gfortran in the /opt/ folder in Terminal, but R looks for it in usr/local/; first I tried manually moving gfortran into usr/local using the sudo mv command in Terminal, but this still did not work
3. Created a Makevars file in the ~/.R folder and then pasted the following text into it, using a combination of these tutorials
- creating file and adding contents to it in Terminal: https://superuser.com/questions/728800/how-to-create-a-file-and-insert-a-line-in-it-using-os-x-terminal
- getting R to find gfortran (?I think this is what this code did):
https://stackoverflow.com/questions/69639782/installing-gfortran-on-macbook-with-apple-m1-chip-for-use-in-r
- what I added to terminal: 
Swetas-MacBook-Pro-3:.R swetapatel$ echo "FC = /opt/gfortran/bin/gfortran">> ~/.R/Makevars
Swetas-MacBook-Pro-3:.R swetapatel$ echo "F77 = /opt/gfortran/bin/gfortran" >> ~/.R/Makevars
Swetas-MacBook-Pro-3:.R swetapatel$ echo "FLIBS = -L/opt/gfortran/lib/gcc/x86_64-apple-darwin20.0" >> ~/.R/Makevars
4. Restarted R and installed SpiecEasi using "install_github("zdk123/SpiecEasi")"

**SPIEC EASI**
- will use counts, not relative abundances (source: https://github.com/zdk123/SpiecEasi/issues/64)
- will use our chi.prune pseq object (already tax.glom'd by species) and for consistency, we will use the same filtering criteria that we used for our Maaslin2 analyses (filter taxa with fewer than 50 counts across the dataset).

```{r}
#Filter and remove unidentified species 
chi.filter <- filter_taxa(chi_prune, function(Abundance) mean(Abundance)>=50, TRUE)
ntaxa(chi.filter) #43
otu <- as.data.frame(otu_table(chi.filter, taxa_are_rows=TRUE))
#need to remove the unidentified species from here: row 11, 25, 37, 38, 40
  #source: https://stackoverflow.com/questions/12328056/how-do-i-delete-rows-in-a-data-frame
#corresponding respectively to: Corynebacterium sp. KPL1859, Streptococcus sp. SK643, Alkalibacterium sp. 20, uncultured Clostridium sp., Nocardioides sp. Root122
otu <- otu[-c(11, 25, 37, 38, 40),]

#already set.seed at the beginning of our R session to 1234
#Spiec easi package in R has wrappers to work directly with pseq objects, so we will import our new otu table back into chi.filter and give it a shot
#import updated otutable into pseq object (convert to matrix first) and take a look
TT <- as.matrix(otu)
otu2 <- otu_table(TT, taxa_are_rows = TRUE)
class(otu2)
otu_table(chi.filter) <- otu2
#can we test it to see if it worked? 
test <- as.data.frame(otu_table(chi.filter, taxa_are_rows=TRUE)) #it worked
remove(TT, test, otu2)

#Spiec Easi
se.mb.chi1 <- spiec.easi(chi.filter, method='mb', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=500))
ig2.mb <- adj2igraph(getRefit(se.mb.chi1), vertex.attr = list(name=taxa_names(chi.filter)))
test <- plot_network(ig2.mb, chi.filter, type = 'taxa', color="Genus")
#I made a network! pretty cool. for some reason the left side keeps getting cut off, even with resizing. Saved as screenshot and a file:
png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/se_mb.png",
    width = 12, height = 9, units = 'in', res = 600)
test
dev.off()

#We should also see what our networks look like using glasso and sparcc (with the latter used in the Segal paper)
#glasso
se.gl.chi1 <- spiec.easi(chi.filter, method='glasso', lambda.min.ratio=1e-2, nlambda=20, pulsar.params=list(rep.num=500))
ig2.gl <- adj2igraph(getRefit(se.gl.chi1), vertex.attr = list(name=taxa_names(chi.filter)))
plot_network(ig2.gl, chi.filter, type = 'taxa', color="Genus") #screenshotted again

#sparcc: can't run from pseq object. Looks like we run using the otu table(?)
sparcc.chi1 <- sparcc(otu) #ERROR; need to transpose the OTU table so OTUs are columns and samples are rows
totu <- t(otu)
sparcc.chi1 <- sparcc(totu)
## Define arbitrary threshold for SparCC correlation matrix for the graph
sparcc.graph <- abs(sparcc.chi1$Cor) >= 0.3
diag(sparcc.graph) <- 0
library(Matrix)
sparcc.graph <- Matrix(sparcc.graph, sparse=TRUE)
## Create igraph objects
ig.sparcc <- adj2igraph(sparcc.graph)

## set size of vertex proportional to clr-mean
vsize    <- rowMeans(clr(otu, 1))+6
plot(ig.sparcc, vertex.size=vsize, vertex.label=NA, main="sparcc")

#We can evaluate the weights on edges networks using the terms from the underlying model. SparCC correlations can be used directly.

library(Matrix)
elist.sparcc <- summary(sparcc.graph*sparcc.chi1$Cor)
hist(elist.sparcc[,3], main='', xlab='edge weights')

#Lets look at the degree statistics from the sparcc network.
library(igraph)
dd.sparcc <- degree.distribution(ig.sparcc)

plot(0:(length(dd.sparcc)-1), dd.sparcc, ylim=c(0,.35), type='b',
      ylab="Frequency", xlab="Degree", main="Degree Distributions")

#Not sure about this quality; will use tutorial from biovcnet github
sparcc.chi1$Cor[1:5, 1:5]
#threw away names; will add back from otu dataframe
rownames(sparcc.chi1$Cor) <- colnames(totu)
colnames(sparcc.chi1$Cor) <- colnames(totu)
rownames(sparcc.chi1$Cov) <- colnames(totu)
colnames(sparcc.chi1$Cov) <- colnames(totu)
#look to confirm
sparcc.chi1$Cor[1:5, 1:5]

#Plotting SparCC correlation
#first generate helper function to get upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
}
#helper function to reorder matrix (?)
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}

plotableSparcc <- sparcc.chi1$Cor %>% reorder_cormat %>% get_upper_tri() %>% reshape2::melt() %>% na.omit()
Sparcc_plot <- plotableSparcc %>% ggplot(aes(x = Var2, y = Var1, fill = value)) + geom_tile() + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1))
Sparcc_plot

#save sparcc plot
png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/sparcc_tile.png",
    width = 12, height = 9, units = 'in', res = 600)
Sparcc_plot
dev.off()

#calculate sparcc p values
#first have to boostrap the sparccc value
tp0 <- proc.time()
out2 <- sparccboot(totu, R = 1000)
tp1 <- proc.time()
tp1 - tp0

#calculate p values from the bootstrapped values
outP <- pval.sparccboot(out2)
data.frame(outP$cors, outP$pvals) %>% head

#these values are hard to use because they dont tell you which p-values correspond to which species; source to fix: https://github.com/zdk123/SpiecEasi/issues/17

cors <- outP$cors
pvals <- outP$pvals
sparCCpcors <- diag(0.5, nrow = dim(sparcc.chi1$Cor)[1], ncol = dim(sparcc.chi1$Cor)[1])
sparCCpcors[upper.tri(sparCCpcors, diag=FALSE)] <- cors
sparCCpcors <- sparCCpcors + t(sparCCpcors)

sparCCpval <- diag(0.5, nrow = dim(sparcc.chi1$Cor)[1], ncol = dim(sparcc.chi1$Cor)[1])
sparCCpval[upper.tri(sparCCpval, diag=FALSE)] <- pvals
sparCCpval <- sparCCpval + t(sparCCpval)

rownames(sparCCpcors) <- colnames(totu)
colnames(sparCCpcors) <- colnames(totu)
rownames(sparCCpval) <- colnames(totu)
colnames(sparCCpval) <- colnames(totu)

sparCCpcors[1:5, 1:5]
sparCCpval[1:5, 1:5]

#now need to process and account for false discovery rates 
#add helper function first
reorder_cor_and_p <- function(cormat, pmat){
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat <-cormat[hc$order, hc$order]
  pmat <- pmat[hc$order, hc$order]
  list(r = cormat, p = pmat)
}

reordered_all_sparcc <- reorder_cor_and_p(sparCCpcors, sparCCpval)
reordered_sparccCor <- reordered_all_sparcc$r
reordered_sparccP<- reordered_all_sparcc$p

sparccCor_processed <- reordered_sparccCor  %>% get_upper_tri() %>% reshape2::melt() %>% na.omit() %>% rename(cor = value)
sparccP_processed <- reordered_sparccP  %>% get_upper_tri() %>% reshape2::melt() %>% na.omit() %>% rename(p = value)

# join the two data frames

SparccP <- left_join(sparccCor_processed, sparccP_processed, by = c("Var1", "Var2")) %>%
  # # remove self correlations
  # filter(Var1 != Var2) %>% 
  # calculate the false discovery rate to adjust for multiple p values
  mutate(fdr = p.adjust(p, method = "BH"))

#what is our false discovery rate threshold? for Maaslin2, we used a q value of 0.2; here, given the high number of pairwise correlations, we can try 0.05 and see how that works.
fdrThresh <- 0.05 # fdr threshold

sparccOkP <- SparccP%>% filter(fdr < fdrThresh) 

SparccP_plot <- SparccP %>% ggplot(aes(x = Var2, y = Var1, fill = cor)) + geom_tile() + scale_fill_gradient2(low = "#800000FF", mid = "white", high = "#4D004B", midpoint = 0) + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + geom_point(data = sparccOkP, shape = 8, size = 0.5)

SparccP_plot

png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/sparccP.png",
    width = 12, height = 9, units = 'in', res = 600)
SparccP_plot
dev.off()

#save our SparccP dataframe as a csv file
write.csv(SparccP, "/Users/swetapatel/OneDrive - Duke University/Fogarty coding/SparCC.csv")
test <- read.csv("/Users/swetapatel/OneDrive - Duke University/Fogarty coding/SparCC.csv") #looks reasonable
remove(test)
```


```{r}
# Create dataframes with overall relative abundances of phyla and genera
melted_df$Phylum <- as.character(melted_df$Phylum)
phyla_abundances <- aggregate(melted_df$Abundance, by=list(Phylum=melted_df$Phylum), FUN=sum)
phyla_abundances$x <- (phyla_abundances$x)/(nsamples(chi.rel))
names(phyla_abundances)[names(phyla_abundances) == 'x'] <- 'phyla_Ab'
sum(phyla_abundances$phyla_Ab)    # Should sum to 1 (sum of relative abundances of phyla)
nrow(phyla_abundances)            # Corresponds to # of unique phyla: 116

melted_df$Genus <- as.character(melted_df$Genus)
genus_abundances <- aggregate(melted_df$Abundance, by=list(Phylum=melted_df$Phylum, Genus=melted_df$Genus,
                                                           OTU=melted_df$OTU), FUN=mean)
genus_abundances <- aggregate(genus_abundances$x, by=list(Phylum=genus_abundances$Phylum,
                                                          Genus=genus_abundances$Genus), FUN=sum)
names(genus_abundances)[names(genus_abundances) == 'x'] <- 'genus_Ab'
sum(genus_abundances$genus_Ab)    # Should sum to 1 (sum of relative abundances of genera)
nrow(genus_abundances)            # Corresponds to # of unique genera: 2146
abundances <- merge(genus_abundances, phyla_abundances, by="Phylum")

melted_df$Species <- as.character(melted_df$Species)
species_abundances <- aggregate(melted_df$Abundance, by=list(Phylum=melted_df$Phylum, Genus=melted_df$Genus,Species=melted_df$Species,
                                                           OTU=melted_df$OTU), FUN=mean)
species_abundances <- aggregate(species_abundances$x, by=list(Phylum=species_abundances$Phylum,
                                                              Genus=species_abundances$Genus, Species=species_abundances$Species), FUN=sum)
names(species_abundances)[names(species_abundances) == 'x'] <- 'species_Ab'
sum(species_abundances$species_Ab)    # Should sum to 1 (sum of relative abundances of genera)
nrow(species_abundances)            # Corresponds to # of unique species: 6708 ***WHY is this different from 6709?###
abundances <- merge(abundances, species_abundances, by=c("Phylum", "Genus"))

phyla_abundances <- arrange(phyla_abundances, desc(phyla_Ab)) 
# Create a df with the top 5 phyla
TOPPhyla <- unique(phyla_abundances$Phylum[1:5])
phylum_df <- phyla_abundances[phyla_abundances$Phylum %in% TOPPhyla,]
phylum_df$Phylum <- factor(phylum_df$Phylum, levels = phylum_df$Phylum[order(-phylum_df$phyla_Ab)])

#create df with top 10 genera
genus_abundances <- arrange(genus_abundances, desc(genus_Ab))  
TOPGenera <- unique(genus_abundances$Genus[1:10])
genus_df <- genus_abundances[genus_abundances$Genus %in% TOPGenera,]
genus_df$Genus <- factor(genus_df$Genus, levels = genus_df$Genus[order(-genus_df$genus_Ab)])

#create df with top 10 species
species_abundances <- arrange(species_abundances, desc(species_Ab))  
TOPSpecies <- unique(species_abundances$Species[1:10])
species_df <- species_abundances[species_abundances$Species %in% TOPSpecies,]
species_df$Species <- factor(species_df$Species, levels = species_df$Species[order(-species_df$species_Ab)])

# Rename species other than top10 as "Other" in creating dataframe relative_df
# Rename genera other than top10 as "Other" in creating dataframe relative_df 
relative_df <- merge(melted_df, abundances, by=c("Genus", "Species"))
#keep getting vector memory exhausted error; need to reboot R so will save melted_df and abundances as csv files
  #source for fix: https://stackoverflow.com/questions/51295402/r-on-macos-error-vector-memory-exhausted-limit-reached
# write.csv(melted_df, 'melted_df.csv')
# write.csv(abundances, 'abundances.csv')
# abundances <- read.csv("abundances.csv")
# melted_df <- read.csv("melted_df.csv")
#note: using the csv files led to very weird errors (sample sums 0.99 instead of 1, 1 phyla missing), 
  #so fixed memory error and reran the code instead of using the abundances and melted_df csv files

relative_df$Species[!(relative_df$Species %in% TOPSpecies)] <- "Other"
sum(relative_df$Abundance)#sums to 143.0008; n=143 so tracks?
table(relative_df$Species) #We have 11 levels for the Species variable, which are consistent with our top 10 + other

```

####DETOUR: Assessing correlation between D. pigrum and S. pyogenes for Matt (will not be included in paper, delete from final RMD file that goes on GitHub)

- will use our "relative_df" dataframe that has abundances for all 6708 species identified and pull out D. pigrum and S. pyogenes

```{r}
###NOT WORKING; come back to 
gas <- filter(relative_df, Species == "Streptococcus pyogenes")
dpig <- filter(relative_df, Species == "Dolosigranulum pigrum")

#drop all but species name and species abundance, rename the abundance variables for each, and then merge into 1 dataframe
gas <- rename(gas, ab.gas = Abundance)
dpig <- rename(dpig, ab.dpig = Abundance)


#Create simple dataframe with abundance variables and sample_id, hiv, age, and merge on sample_id
corr_mk <- dpig[c("sample_id", "age", "hiv", "ab.dpig")]
test <- gas[c("sample_id", "ab.gas")]
corr_mk <- merge(corr_mk, test, by ="sample_id", sort = TRUE)

write.csv(corr_mk, "/Users/swetapatel/OneDrive - Duke University/Fogarty coding/corr_gas_dpig_forMK.csv", row.names = F)
corr_mk <- read.csv("corr_gas_dpig_forMK.csv")

cor.test(corr_mk$ab.dpig, corr_mk$ab.gas, method = "pearson")  #P=0.13, cor = -0.127
cor.test(corr_mk$ab.dpig, corr_mk$ab.gas, method = "spearman", exact = FALSE)  #P=0.35, estimate = -0.079
#no correlation BUT large number of zeros for GAS so may be down to sample size

library(ggtext)

mk <- ggplot(data = corr_mk, aes(x = ab.dpig, y = ab.gas)) + 
  geom_point() + 
  geom_smooth(method = "lm", color="red", size=0.5, se = FALSE) +
  labs(title="*D. pigrum* vs *S. pyogenes*",x="*D. pigrum*", y = "*S. pyogenes*")+
  geom_text(size=6, x=0.4, y=0.003, label="r = - 0.08, p = 0.35") +
  scale_x_continuous(breaks = seq(-0.1, 0.7, 0.2), limits = c(0, 0.7)) +
  theme_bw() +
  theme(
    plot.title = ggtext::element_markdown(size=14, hjust=0.5),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    legend.position = "right",
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 14),
    axis.title.x = ggtext::element_markdown(),
    axis.title.y = ggtext::element_markdown())

png(file="/Users/swetapatel/OneDrive - Duke University/Fogarty coding/corr_forMK.png",
     width = 5, height = 5, units = 'in', res = 600)
mk
dev.off()

```




####HEU-CLWH Sibling Comparisons

Create our limited pseq object
```{r}
sib_pair = subset_samples(pruned, sample_id == "B.09.CHI" | sample_id == "B.09.SIB" | sample_id == "B.16.CHI" | 
                            sample_id == "B.16.SIB" | sample_id == "B.17.CHI" | sample_id == "B.17.SIB" | sample_id == "B.20.CHI" |
                            sample_id == "B.20.SIB" | sample_id == "B.23.CHI" | sample_id == "B.23.SIB" | sample_id == "B.25.CHI" |
                            sample_id == "B.25.SIB" | sample_id == "B.32.CHI" | sample_id == "B.32.SIB" | sample_id == "B.35.CHI" |
                            sample_id == "B.35.SIB" | sample_id == "B.48.CHI" | sample_id == "B.48.SIB")

sib <- data.frame(sample_data(sib_pair))

#see 'Fog Kaiju sub-analyses 5-26-22.R' for full code, but cleaned + simplified metadata with standardized variables already created and saved:
sib3 <- read.csv("/Users/swetapatel/OneDrive - Duke University/Fogarty coding/Sequencing/sibpairs.csv")

```